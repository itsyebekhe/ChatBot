<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Gemma Chat">
    <meta name="application-name" content="Gemma Chat">
    <meta name="theme-color" content="#0d6efd">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192x192.png">
    <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">

    <title>Gemma Chat Enhanced</title>

    <!-- highlight.js CSS (choose a theme) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css" id="highlight-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css" id="highlight-theme-light" disabled>

    <style>
        /* --- General Reset & Base Styles --- */
        :root {
            --primary-color: #0d6efd;
            --primary-hover-color: #0a58ca;
            --primary-active-color: #0a58ca;
            --secondary-color: #6c757d;
            --secondary-hover-color: #5c636a;
            --text-light: #f8f9fa;
            --text-dark: #212529;
            --bg-light: #ffffff;
            --bg-medium-light: #f1f3f5;
            --bg-dark: #212529;
            --bg-medium-dark: #343a40;
            --border-light: #dee2e6;
            --border-dark: #495057;
            --code-bg-light: #e0e0e0;
            --code-bg-dark: #454d54; /* Adjusted */
            --pre-bg-light: #f8f9fa; /* Lighter pre background */
            --pre-bg-dark: #2c3237;  /* Darker pre background */
            --input-bg-light: var(--bg-medium-light);
            --input-bg-dark: var(--bg-medium-dark);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { height: 100%; overscroll-behavior-y: contain; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            height: 100%; display: flex; flex-direction: column;
            background: var(--bg-light); color: var(--text-dark);
            transition: background 0.3s ease, color 0.3s ease;
            line-height: 1.45; overflow: hidden;
        }
        body.dark {
            background: var(--bg-dark); color: var(--text-light);
            --primary-hover-color: #0b5ed7;
            --primary-active-color: #0b5ed7;
            --secondary-hover-color: #52585d;
        }
        body.dark #highlight-theme-dark { display: block; /* Correct way to enable */ enabled: true; }
        body.dark #highlight-theme-light { display: none; /* Correct way to disable */ enabled: false; }
        body:not(.dark) #highlight-theme-dark { display: none; /* Correct way to disable */ enabled: false; }
        body:not(.dark) #highlight-theme-light { display: block; /* Correct way to enable */ enabled: true; }


        /* --- Layout --- */
        .chat-wrapper { display: flex; flex-direction: column; flex-grow: 1; height: 100%; overflow: hidden;}
        .chat-header, .chat-footer { flex-shrink: 0; position: sticky; z-index: 10; }
        .chat-header { top: 0; border-bottom: 1px solid var(--border-light); background: var(--bg-light); box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .chat-footer { bottom: 0; border-top: 1px solid var(--border-light); background: var(--bg-light); box-shadow: 0 -1px 3px rgba(0,0,0,0.05); }
        .chat-body { flex-grow: 1; padding: 10px 10px 5px 10px; overflow-y: auto; overscroll-behavior-y: contain; -webkit-overflow-scrolling: touch; }
        body.dark .chat-header, body.dark .chat-footer { border-color: var(--border-dark); background: var(--bg-medium-dark); box-shadow: 0 1px 3px rgba(0,0,0,0.2); }

        /* --- Header --- */
        .chat-header { padding: 8px 10px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 5px; }
        .header-left { display: flex; align-items: center; gap: 8px; flex-grow: 1; /* Allow search to take space */ min-width: 100px; }
        .chat-header h1 { font-size: 1.1rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .controls { display: flex; gap: 5px; flex-wrap: nowrap; /* Prevent controls wrapping too early */}
        #search-input {
            padding: 5px 8px; border-radius: 15px; border: 1px solid var(--border-light); font-size: 0.8rem;
            width: 40px; /* Start small */ transition: width 0.3s ease, padding 0.3s ease;
            background-color: var(--input-bg-light);
        }
        #search-input:focus { width: 150px; /* Expand on focus */ outline: none; border-color: var(--primary-color); padding-left: 10px; padding-right: 10px; }
        @media (min-width: 500px) { #search-input {width: 120px;} #search-input:focus { width: 200px; } } /* Larger on wider screens */
        body.dark #search-input { background: var(--input-bg-dark); border-color: var(--border-dark); color: var(--text-light); }


        /* --- Footer --- */
        .chat-footer { padding: 8px 10px; display: flex; flex-direction: column; gap: 5px; }
        .persona-prompt-row, .api-key-row, .input-row { display: flex; gap: 5px; width: 100%; align-items: center; }
        .input-row { gap: 8px; } /* More gap for main input */
        #persona-select { flex-grow: 1; padding: 6px 8px; border-radius: 5px; border: 1px solid var(--border-light); font-size: 0.85rem; height: 32px; background: var(--bg-light); color: var(--text-dark);}
        #prompt-library-btn { font-size: 0.9rem; padding: 0 8px; min-width: 32px; height: 32px; background: var(--secondary-color); border-radius: 5px;}
        body.dark #persona-select { background: var(--input-bg-dark); border-color: var(--border-dark); color: var(--text-light); }

        /* --- Inputs & Buttons --- */
        input[type="text"], input[type="password"], #api-key-input { /* Updated selector */
            flex-grow: 1; padding: 10px 15px; border: none; border-radius: 20px;
            font-size: 0.95rem; height: 42px; /* Taller */
            background-color: var(--input-bg-light);
            color: var(--text-dark); /* Ensure text color */
        }
        body.dark input[type="text"], body.dark input[type="password"], body.dark #api-key-input { background-color: var(--input-bg-dark); color: var(--text-light); }
        input:focus, #api-key-input:focus { outline: none; box-shadow: 0 0 0 2px var(--primary-color); }

        button {
            padding: 0 12px; height: 36px; background: var(--primary-color); color: var(--text-light);
            border: none; border-radius: 18px; cursor: pointer; font-size: 0.9rem; font-weight: 500;
            transition: background 0.2s ease, transform 0.1s ease;
            display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0;
        }
        button:hover { background: var(--primary-hover-color); }
        button:active { transform: scale(0.97); background: var(--primary-active-color); }
        button:disabled { background: var(--secondary-color) !important; /* Override hover/active */ cursor: not-allowed; transform: none; opacity: 0.7;}

        #api-key-input { height: 36px; flex-grow: 1; } /* API key slightly smaller */
        #api-btn { height: 36px; min-width: 50px; font-size: 0.8rem; background: #198754;}
        #api-btn:hover { background: #157347;}

        #file-btn, #send-btn {
            min-width: 42px; height: 42px; /* Match input height */
            padding: 0; border-radius: 50%; font-size: 1.4rem; line-height: 1;
            background: var(--secondary-color);
        }
        #file-btn:hover, #send-btn:hover:not(:disabled) { background: var(--secondary-hover-color); } /* Only hover if not disabled */
        #send-btn { background: var(--primary-color); }
        #send-btn:hover:not(:disabled) { background: var(--primary-hover-color); }

        #clear-btn, #theme-btn, #lang-btn {
             background: var(--secondary-color);
             min-width: 36px; /* Square-ish */
             height: 36px;
             padding: 0;
             font-size: 1.2rem;
             border-radius: 50%; /* Circular */
        }
         #clear-btn:hover, #theme-btn:hover, #lang-btn:hover { background: var(--secondary-hover-color); }


        #file-input { display: none; }

        /* --- Chat Body & Messages --- */
        .message {
            display: flex; /* Use flex for inline actions */
            flex-direction: column; /* Stack content and actions */
            margin: 5px 0 10px 0; /* More margin bottom */ padding: 8px 12px; border-radius: 12px; max-width: 85%; /* Slightly wider */
            line-height: 1.5; font-size: 0.95rem; word-wrap: break-word;
            position: relative; /* For pinning icon */
            transition: background-color 0.3s ease; /* For search highlight */
            animation: fadeIn 0.3s ease; /* Keep fade in */
        }
        .message.pinned::before {
            content: 'üìå'; position: absolute; top: -5px; right: -5px; font-size: 0.8em;
            background: var(--primary-color); color: white; border-radius: 50%; width: 16px; height: 16px;
            text-align: center; line-height: 16px; z-index: 1; /* Ensure pin is above */
        }
        body.dark .message.pinned::before { background: var(--primary-hover-color); }


        .message-content { margin-bottom: 5px; } /* Space before actions */
        .message-actions { display: none; /* Hidden by default */ gap: 8px; /* More gap */ align-items: center; margin-top: 5px; opacity: 0.7; }
        .message:hover .message-actions, .message:focus-within .message-actions { display: flex; /* Show on hover/focus */ }
        .message-actions button {
            background: none; border: none; color: inherit; /* Inherit color */
            padding: 2px; height: auto; min-width: auto; font-size: 1.1em; /* Larger icons */ cursor: pointer; border-radius: 3px;
            line-height: 1; /* Prevent extra space */
        }
        .message-actions button:hover { background-color: rgba(0,0,0,0.1); transform: scale(1.1); }
        body.dark .message-actions button:hover { background-color: rgba(255,255,255,0.1); }


        .user-msg { background: var(--primary-color); color: var(--text-light); margin-left: auto; border-bottom-right-radius: 4px; }
        .ai-msg { background: var(--bg-medium-light); color: var(--text-dark); margin-right: auto; border-bottom-left-radius: 4px; }
        body.dark .user-msg { background: var(--primary-hover-color); }
        body.dark .ai-msg { background: var(--input-bg-dark); color: var(--text-light); }

        /* Markdown & Code */
        .ai-msg .message-content p:last-child { margin-bottom: 0; } /* Target specifically */
        .ai-msg .message-content p { margin: 0 0 8px; }
        .ai-msg .message-content ul, .ai-msg .message-content ol { margin: 5px 0 8px 20px; padding-left: 15px; }
        .ai-msg .message-content li { margin: 4px 0; }
        .ai-msg .message-content strong { font-weight: 600; }
        .ai-msg .message-content em { font-style: italic; }
        .ai-msg .message-content code { /* Target code inside ai messages */
            background: var(--code-bg-light); padding: 2px 5px; border-radius: 4px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.88em; color: inherit; /* Ensure text color matches */
        }
        body.dark .ai-msg .message-content code { background: var(--code-bg-dark); }

        .ai-msg .message-content pre { /* Target pre inside ai messages */
             background: var(--pre-bg-light); padding: 10px; border-radius: 6px;
             overflow-x: auto; margin: 10px 0; border: 1px solid var(--border-light);
             position: relative; /* For copy button */
        }
         body.dark .ai-msg .message-content pre { background: var(--pre-bg-dark); border-color: var(--border-dark); }
         .ai-msg .message-content pre code { background: none !important; padding: 0; border-radius: 0; font-size: 0.9em; border: none; }

         /* Highlight.js adjustment */
         .hljs { background: transparent !important; /* Make hljs background transparent */ }

        /* Copy button for code blocks */
        .copy-code-btn {
            position: absolute; top: 5px; right: 5px; background: var(--secondary-color); color: white;
            border: none; border-radius: 4px; padding: 3px 6px; font-size: 0.75em; cursor: pointer; opacity: 0.7; transition: opacity 0.2s, background-color 0.2s;
            z-index: 1; /* Ensure button is clickable */
        }
        .copy-code-btn:hover { opacity: 1; }
        .copy-code-btn.copied { background: #198754; opacity: 1;} /* Green when copied */
        body.dark .copy-code-btn { background: var(--secondary-hover-color); color: var(--text-light); }


        /* Thinking Indicator */
        .thinking { display: flex; align-items: center; gap: 6px; padding: 10px 12px; margin: 8px 0; max-width: fit-content; margin-right: auto; background: var(--bg-medium-light); border-radius: 12px; border-bottom-left-radius: 4px; }
        body.dark .thinking { background: var(--input-bg-dark); }
        .dot { width: 7px; height: 7px; background: #adb5bd; border-radius: 50%; animation: bounce 1.3s infinite ease-in-out; }
        body.dark .dot { background: #dee2e6; }
        .dot:nth-child(2) { animation-delay: 0.16s; }
        .dot:nth-child(3) { animation-delay: 0.32s; }

        /* Search Highlight */
        .message.search-highlight {
            background-color: rgba(255, 255, 0, 0.4); /* Yellow highlight */
            border-radius: 12px; /* Ensure radius matches */
        }
        body.dark .message.search-highlight {
             background-color: rgba(255, 255, 100, 0.3); /* Lighter yellow for dark */
        }

        /* Prompt Library Modal */
        .modal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.5); backdrop-filter: blur(3px);
            justify-content: center; align-items: center;
        }
        .modal.active { display: flex; animation: fadeInModal 0.3s ease; }
        .modal-content {
            background-color: var(--bg-light); margin: auto; padding: 20px; border: 1px solid var(--border-light);
            width: 90%; max-width: 500px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            max-height: 80vh; display: flex; flex-direction: column;
        }
        body.dark .modal-content { background-color: var(--bg-medium-dark); border-color: var(--border-dark); }

        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-light);}
        body.dark .modal-header { border-color: var(--border-dark); }
        .modal-header h2 { margin: 0; font-size: 1.2rem; }
        .close-modal-btn { background: none; border: none; font-size: 1.8rem; cursor: pointer; padding: 0 5px; color: inherit; line-height: 1;}
        .modal-body { overflow-y: auto; margin-bottom: 15px; flex-grow: 1; padding-right: 5px; /* Space for scrollbar */}
        .prompt-list { list-style: none; padding: 0; }
        .prompt-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 5px; border-bottom: 1px solid var(--border-light); transition: background-color 0.2s ease; }
        .prompt-item:hover { background-color: rgba(0,0,0,0.05); }
        body.dark .prompt-item { border-color: var(--border-dark); }
        body.dark .prompt-item:hover { background-color: rgba(255,255,255,0.05); }

        .prompt-item span { cursor: pointer; flex-grow: 1; margin-right: 10px; font-size: 0.95rem; }
        .prompt-item span:hover { color: var(--primary-color); }
        .prompt-item button { font-size: 0.9em; padding: 2px 5px; height: auto; min-width: auto; background: #dc3545; border-radius: 4px; line-height: 1;} /* Delete button */
        .modal-footer { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; padding-top: 15px; border-top: 1px solid var(--border-light); }
        body.dark .modal-footer { border-color: var(--border-dark); }
        #new-prompt-name, #new-prompt-text { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--border-light); font-size: 0.9rem; }
        body.dark #new-prompt-name, body.dark #new-prompt-text { background: var(--input-bg-dark); border-color: var(--border-dark); color: var(--text-light); }
        #save-prompt-btn { align-self: flex-end; min-width: 100px; }


        /* --- Animations --- */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes bounce { 0%, 70%, 100% { transform: scale(0.5); opacity: 0.5; } 35% { transform: scale(1.0); opacity: 1; } }
        @keyframes fadeInModal { from { opacity: 0; } to { opacity: 1; } }

        /* Utility Class */
        .hidden { display: none; }

    </style>
</head>
<body class="${localStorage.getItem('theme') === 'dark' ? 'dark' : ''}">

    <div class="chat-wrapper">
        <!-- Header -->
        <div class="chat-header">
            <div class="header-left">
                 <h1 data-en="Gemma Chat" data-fa="⁄Üÿ™ ŸÜŸàÿß">Gemma Chat</h1>
                 <input type="search" id="search-input" placeholder="Search..." data-en-placeholder="Search..." data-fa-placeholder="ÿ¨ÿ≥ÿ™ÿ¨Ÿà...">
            </div>
            <div class="controls">
                <button id="theme-btn" title="Toggle Theme">üåì</button> <!-- Icon Example -->
                <button id="lang-btn" title="Toggle Language">üåê</button> <!-- Icon Example -->
                <button id="clear-btn" title="Clear Chat">üóëÔ∏è</button> <!-- Icon Example -->
            </div>
        </div>

        <!-- Chat Body -->
        <div class="chat-body" id="chat-body"></div>

        <!-- Footer -->
        <div class="chat-footer">
            <div class="persona-prompt-row">
                 <select id="persona-select" title="Select AI Persona">
                     <option value="">Default Persona</option>
                     <!-- Options added by JS -->
                 </select>
                 <button id="prompt-library-btn" title="Prompt Library">üìö</button>
            </div>
             <div class="api-key-row">
                 <input type="password" id="api-key-input" <!-- Use password type -->
                       placeholder="OpenRouter API Key"
                       data-en-placeholder="OpenRouter API Key"
                       data-fa-placeholder="⁄©ŸÑ€åÿØ API OpenRouter"
                       value="${localStorage.getItem('apiKey') || ''}">
                <button id="api-btn" data-en="Key" data-fa="⁄©ŸÑ€åÿØ">Key</button>
            </div>
            <div class="input-row">
                <button id="file-btn" title="Attach file">üìé</button>
                <input type="text" id="chat-input"
                       placeholder="Type message or ask about file..."
                       data-en-placeholder="Type message or ask about file..."
                       data-fa-placeholder="Ÿæ€åÿßŸÖ ÿ™ÿß€åŸæ ⁄©ŸÜ€åÿØ €åÿß ÿØÿ±ÿ®ÿßÿ±Ÿá ŸÅÿß€åŸÑ ÿ®Ÿæÿ±ÿ≥€åÿØ...">
                <button id="send-btn" title="Send message">‚û§</button>
                <input type="file" id="file-input" class="hidden" accept="image/*,application/pdf,text/plain"> <!-- Added hidden class -->
            </div>
        </div>
    </div>

    <!-- Prompt Library Modal -->
    <div id="prompt-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 data-en="Prompt Library" data-fa="⁄©ÿ™ÿßÿ®ÿÆÿßŸÜŸá ÿßÿπŸÑÿßŸÜ‚ÄåŸáÿß">Prompt Library</h2>
                <button id="close-modal-btn" class="close-modal-btn">√ó</button>
            </div>
            <div class="modal-body">
                <ul id="prompt-list" class="prompt-list">
                    <!-- Prompt items will be added here -->
                </ul>
            </div>
            <div class="modal-footer">
                <input type="text" id="new-prompt-name" placeholder="Prompt Name (e.g., Code Explainer)" data-en-placeholder="Prompt Name..." data-fa-placeholder="ŸÜÿßŸÖ ÿßÿπŸÑÿßŸÜ...">
                <textarea id="new-prompt-text" rows="3" placeholder="Prompt Text (e.g., Explain the following code:)" data-en-placeholder="Prompt Text..." data-fa-placeholder="ŸÖÿ™ŸÜ ÿßÿπŸÑÿßŸÜ..."></textarea>
                <button id="save-prompt-btn" data-en="Save Prompt" data-fa="ÿ∞ÿÆ€åÿ±Ÿá ÿßÿπŸÑÿßŸÜ">Save Prompt</button>
            </div>
        </div>
    </div>


    <!-- Libraries (Place before your main script) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/14.0.0/markdown-it.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Configure pdf.js worker
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        } else {
             console.error("pdf.js library not loaded correctly.");
        }
    </script>

    <!-- Your Main App Script -->
    <script>
        (function() {
            "use strict";

            // --- State Variables ---
            let conversation = JSON.parse(localStorage.getItem('conversation_v2')) || []; // v2 for new structure
            let apiKey = localStorage.getItem('apiKey') || '';
            let isTyping = false; // Tracks if AI is generating response
            let isProcessingFile = false; // Tracks file reading/extraction
            let isDark = localStorage.getItem('theme') === 'dark';
            let isPersian = localStorage.getItem('lang') === 'fa';
            let personas = JSON.parse(localStorage.getItem('personas')) || [
                { name: "Default Persona", prompt: "" },
                { name: "Code Assistant", prompt: "You are a helpful coding assistant. Provide clear explanations and code examples where possible. Format code using markdown code blocks with language identifiers." },
                { name: "Concise Summarizer", prompt: "Summarize the key points of the provided text concisely using bullet points." }
            ];
            let currentPersonaPrompt = localStorage.getItem('currentPersonaPrompt') || "";
            let prompts = JSON.parse(localStorage.getItem('prompts')) || [
                 { name: "Explain Code", text: "Explain the following code snippet:\n```\n{selection}\n```" },
                 { name: "Summarize Text", text: "Please summarize the key points of the following text:\n\n{clipboard}" }
            ];
            let currentAbortController = null; // For aborting fetch streams
            let attachedFileInfo = null; // Holds info about the currently attached (but not sent) file

            // --- DOM Elements ---
            const chatBody = document.getElementById('chat-body');
            const apiKeyInput = document.getElementById('api-key-input');
            const chatInput = document.getElementById('chat-input');
            const fileInput = document.getElementById('file-input');
            const themeBtn = document.getElementById('theme-btn');
            const langBtn = document.getElementById('lang-btn');
            const clearBtn = document.getElementById('clear-btn');
            const apiBtn = document.getElementById('api-btn');
            const sendBtn = document.getElementById('send-btn');
            const fileBtn = document.getElementById('file-btn');
            const searchInput = document.getElementById('search-input');
            const personaSelect = document.getElementById('persona-select');
            const promptLibraryBtn = document.getElementById('prompt-library-btn');
            const promptModal = document.getElementById('prompt-modal');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const promptListUl = document.getElementById('prompt-list');
            const newPromptNameInput = document.getElementById('new-prompt-name');
            const newPromptTextInput = document.getElementById('new-prompt-text');
            const savePromptBtn = document.getElementById('save-prompt-btn');
            const highlightThemeDark = document.getElementById('highlight-theme-dark');
            const highlightThemeLight = document.getElementById('highlight-theme-light');

            // --- Libraries Init ---
            const md = window.markdownit({
                html: false, // Disable HTML tags in markdown
                linkify: true,
                typographer: true,
                highlight: function (str, lang) { // Syntax Highlighting
                    if (lang && window.hljs && window.hljs.getLanguage(lang)) {
                        try {
                            // Wrap with pre and code, add copy button
                            return `<pre class="hljs"><code>${window.hljs.highlight(str, { language: lang, ignoreIllegals: true }).value}</code><button class="copy-code-btn" title="Copy code">Copy</button></pre>`;
                        } catch (__) {}
                    }
                    // Fallback for no language or error
                    return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code><button class="copy-code-btn" title="Copy code">Copy</button></pre>';
                }
            });

            // --- Core Functions ---

            function updateUI() {
                document.body.classList.toggle('dark', isDark);
                document.body.classList.toggle('rtl', isPersian);

                // Update text/placeholders using attributes for easier management
                document.querySelectorAll('[data-en]').forEach(el => {
                     el.textContent = isPersian ? el.getAttribute('data-fa') : el.getAttribute('data-en');
                });
                 document.querySelectorAll('[data-en-placeholder]').forEach(el => {
                     el.placeholder = isPersian ? el.getAttribute('data-fa-placeholder') : el.getAttribute('data-en-placeholder');
                });

                // Update button titles (for icon buttons)
                themeBtn.title = isDark ? (isPersian ? 'ÿ™ŸÖ ÿ±Ÿàÿ¥ŸÜ' : 'Light Theme') : (isPersian ? 'ÿ™ŸÖ ÿ™ÿßÿ±€å⁄©' : 'Dark Theme');
                langBtn.title = isPersian ? 'ÿ≤ÿ®ÿßŸÜ ÿßŸÜ⁄ØŸÑ€åÿ≥€å' : 'Persian Language';
                clearBtn.title = isPersian ? 'Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ⁄Üÿ™' : 'Clear Chat';
                fileBtn.title = isPersian ? 'Ÿæ€åŸàÿ≥ÿ™ ŸÅÿß€åŸÑ' : 'Attach file';
                sendBtn.title = isPersian ? 'ÿßÿ±ÿ≥ÿßŸÑ Ÿæ€åÿßŸÖ' : 'Send message';
                promptLibraryBtn.title = isPersian ? '⁄©ÿ™ÿßÿ®ÿÆÿßŸÜŸá ÿßÿπŸÑÿßŸÜ‚ÄåŸáÿß' : 'Prompt Library';
                apiBtn.textContent = isPersian ? '⁄©ŸÑ€åÿØ' : 'Key'; // Assuming Key is ok for both

                // Update theme-color meta and highlight theme link enablement
                 const themeColorMeta = document.querySelector('meta[name="theme-color"]');
                 if (themeColorMeta) {
                     themeColorMeta.content = isDark ? '#343a40' : '#0d6efd';
                 }
                 // Correctly enable/disable stylesheets
                 highlightThemeDark.disabled = !isDark;
                 highlightThemeLight.disabled = isDark;

                 // Populate Persona Dropdown
                 populatePersonaSelect();

                 // Update input placeholder based on attached file
                 updateInputPlaceholder();
            }

            function populatePersonaSelect() {
                const selectedValue = personaSelect.value; // Preserve selection if possible
                personaSelect.innerHTML = ''; // Clear existing
                personas.forEach((p) => {
                    const option = document.createElement('option');
                    option.value = p.prompt;
                    option.textContent = p.name;
                    // Reselect the previously selected or the one matching currentPersonaPrompt
                    option.selected = (selectedValue === p.prompt) || (!selectedValue && p.prompt === currentPersonaPrompt);
                    personaSelect.appendChild(option);
                });
                 // Ensure currentPersonaPrompt state matches selection after population
                 currentPersonaPrompt = personaSelect.value;
            }

            function scrollToBottom(instant = false) {
                setTimeout(() => {
                    chatBody.scrollTo({
                        top: chatBody.scrollHeight,
                        behavior: instant ? 'instant' : 'smooth'
                    });
                }, 50);
            }

            function generateMessageId() {
                return Date.now().toString(36) + Math.random().toString(36).substring(2);
            }

            function loadConversation() {
                chatBody.innerHTML = '';
                let needsScroll = conversation.length > 0;

                conversation.forEach(msg => addMessageElement(msg, false)); // Add message element without scroll

                apiKeyInput.value = localStorage.getItem('apiKey') || ''; // Load key
                currentPersonaPrompt = localStorage.getItem('currentPersonaPrompt') || ""; // Load persona

                updateUI(); // Includes populating persona select

                if (needsScroll) {
                    setTimeout(() => chatBody.scrollTop = chatBody.scrollHeight, 100); // Instant scroll on load
                }
            }

            /**
             * Creates the DOM element for a message object.
             * @param {object} message - The message object from conversation array.
             * @param {boolean} [shouldScroll=true] - Whether to scroll after adding.
             * @returns {HTMLElement} The created message div.
             */
            function addMessageElement(message, shouldScroll = true) {
                const msgDiv = document.createElement('div');
                msgDiv.className = `message ${message.role === 'user' ? 'user-msg' : 'ai-msg'}`;
                msgDiv.dataset.messageId = message.id;
                if (message.pinned) {
                     msgDiv.classList.add('pinned');
                }

                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';

                if (message.role === 'user') {
                    // Display text part
                    const textPart = message.content.find(p => p.type === 'text');
                    if (textPart) {
                        contentDiv.textContent = textPart.text;
                    } else {
                        contentDiv.textContent = '[Empty User Message]';
                    }

                    // Display file info if present in the message object
                    const filePart = message.content.find(p => p.type === 'image_url' || p.type === 'file_info');
                    if(filePart){
                        const fileInfoSpan = document.createElement('span');
                        fileInfoSpan.style.fontSize = '0.8em';
                        fileInfoSpan.style.opacity = '0.8';
                        fileInfoSpan.style.display = 'block';
                        fileInfoSpan.style.marginTop = '5px'; // Add space
                        fileInfoSpan.textContent = filePart.type === 'image_url'
                            ? (isPersian ? '[ÿ™ÿµŸà€åÿ± Ÿæ€åŸàÿ≥ÿ™ ÿ¥ÿØ]' : '[Image Attached]')
                            : (isPersian ? `[ŸÅÿß€åŸÑ: ${filePart.file_info?.name || 'Unknown'}]` : `[File: ${filePart.file_info?.name || 'Unknown'}]`);
                         contentDiv.appendChild(fileInfoSpan);
                    }

                } else { // AI message
                     const textPart = message.content.find(p => p.type === 'text');
                     contentDiv.innerHTML = md.render(textPart?.text || ''); // Render markdown
                    // Apply highlighting and add copy buttons AFTER innerHTML is set
                    contentDiv.querySelectorAll('pre code').forEach(block => {
                         try {
                             window.hljs.highlightElement(block);
                         } catch (e) { console.error("Highlight.js error:", e); }
                     });
                    contentDiv.querySelectorAll('pre button.copy-code-btn').forEach(btn => {
                         btn.addEventListener('click', handleCopyCodeClick);
                    });
                }
                msgDiv.appendChild(contentDiv);

                // Add Inline Actions Container
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                // Use textContent for emojis to avoid potential HTML injection if modifying later
                actionsDiv.innerHTML = `
                    <button class="copy-btn" title="${isPersian ? '⁄©Ÿæ€å' : 'Copy'}">üìã</button>
                    <button class="pin-btn" title="${message.pinned ? (isPersian ? 'ÿ®ÿ±ÿØÿßÿ¥ÿ™ŸÜ ÿ≥ŸÜÿ¨ÿßŸÇ' : 'Unpin') : (isPersian ? 'ÿ≥ŸÜÿ¨ÿßŸÇ ⁄©ÿ±ÿØŸÜ' : 'Pin')}">${message.pinned ? 'üìå' : 'üìç'}</button>
                    ${message.role === 'assistant' ? `<button class="retry-btn" title="${isPersian ? 'ÿ™ŸÑÿßÿ¥ ŸÖÿ¨ÿØÿØ' : 'Retry'}">üîÑ</button>` : ''}
                    <button class="read-aloud-btn" title="${isPersian ? 'ÿÆŸàÿßŸÜÿØŸÜ ŸÖÿ™ŸÜ' : 'Read Aloud'}">üîä</button>
                `;
                msgDiv.appendChild(actionsDiv);

                chatBody.appendChild(msgDiv);

                // Add listeners for inline actions using event delegation might be more performant for many messages,
                // but direct listeners are simpler here.
                actionsDiv.querySelector('.copy-btn')?.addEventListener('click', () => handleCopyMessage(message.id));
                actionsDiv.querySelector('.pin-btn')?.addEventListener('click', () => handlePinMessage(message.id));
                actionsDiv.querySelector('.retry-btn')?.addEventListener('click', () => handleRetryMessage(message.id));
                actionsDiv.querySelector('.read-aloud-btn')?.addEventListener('click', () => handleReadAloud(message.id));


                if (shouldScroll) {
                    scrollToBottom();
                }
                 return msgDiv;
            }

             /**
             * Updates an existing AI message element with new streamed content.
             * @param {string} messageId - The ID of the message to update.
             * @param {string} textChunk - The new chunk of text to append.
             * @param {boolean} isFinal - Whether this is the last chunk.
             */
            function updateStreamingMessage(messageId, textChunk, isFinal) {
                 const msgDiv = chatBody.querySelector(`div[data-message-id="${messageId}"]`);
                 if (!msgDiv) return; // Message might have been cleared

                 const contentDiv = msgDiv.querySelector('.message-content');
                 if (!contentDiv) return;

                 const msgIndex = conversation.findIndex(m => m.id === messageId);
                 if (msgIndex === -1) return; // Message not found in state

                 // Ensure the content array exists and has a text part
                 if (!conversation[msgIndex].content) conversation[msgIndex].content = [];
                 let textPart = conversation[msgIndex].content.find(p => p.type === 'text');
                 if (!textPart) {
                     textPart = { type: 'text', text: '' };
                     conversation[msgIndex].content.push(textPart);
                 }

                 // Append text to the state
                 textPart.text += textChunk;

                 // Update the DOM using markdown render (can be slow, but ensures correct formatting)
                 // Potential optimization: only re-render full markdown on final chunk or every N chunks.
                 contentDiv.innerHTML = md.render(textPart.text);

                 // Re-apply highlighting and listeners after rendering
                 contentDiv.querySelectorAll('pre code').forEach(block => {
                     try { window.hljs.highlightElement(block); } catch(e) { console.error("hljs error", e); }
                 });
                 contentDiv.querySelectorAll('pre button.copy-code-btn').forEach(btn => {
                     btn.addEventListener('click', handleCopyCodeClick);
                 });

                 if (isFinal) {
                     console.log("Stream finished for message:", messageId);
                     saveState(); // Save final state
                     isTyping = false; // Reset typing flag ONLY when stream definitively ends
                     setInputsDisabled(false); // Re-enable inputs
                     chatInput.focus(); // Focus input for next message
                 }

                 // Scroll only if the user hasn't scrolled up significantly
                 const isScrolledToBottom = chatBody.scrollHeight - chatBody.scrollTop - chatBody.clientHeight < 100;
                 if (isScrolledToBottom) {
                    scrollToBottom();
                 }
            }


            function addThinking() {
                 const existingThinking = chatBody.querySelector('.thinking');
                 if(existingThinking) { removeThinking(existingThinking); }

                const thinkingDiv = document.createElement('div');
                thinkingDiv.className = 'thinking';
                thinkingDiv.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
                chatBody.appendChild(thinkingDiv);
                scrollToBottom();
                return thinkingDiv;
            }

            function removeThinking(thinkingElement) {
                if (thinkingElement && thinkingElement.parentNode === chatBody) {
                    chatBody.removeChild(thinkingElement);
                }
            }

            /**
             * Creates a message object for the conversation array.
             * @param {string} textPrompt - The main text content.
             * @param {string} role - 'user' or 'assistant'.
             * @param {object} fileData - Optional data about an attached file (base64, extractedText, name, type, size).
             * @param {string|null} id - Optional existing ID.
             * @param {boolean} pinned - Optional pinned status.
             * @returns {object} The message object.
             */
            function createMessageObject(textPrompt, role, fileData = null, id = null, pinned = false) {
                 let content = [{ type: 'text', text: textPrompt }];

                 if (fileData) {
                     if (fileData.base64Data) { // Image
                         content.push({ type: 'image_url', image_url: { url: fileData.base64Data } });
                     }
                     if (fileData.name) { // PDF/Text (add file info for context/display)
                        content.push({ type: 'file_info', file_info: { name: fileData.name, size: fileData.size, type: fileData.type }});
                        if (fileData.extractedText) {
                            // Add extracted text as a separate text part for the AI
                            content.push({ type: 'text', text: `\n\n[Start of ${fileData.name} content]\n${fileData.extractedText}\n[End of ${fileData.name} content]` });
                        }
                     }
                 }

                return {
                    id: id || generateMessageId(),
                    role: role,
                    content: content,
                    timestamp: Date.now(),
                    pinned: pinned
                };
            }


            function saveState() {
                try {
                    localStorage.setItem('conversation_v2', JSON.stringify(conversation));
                    localStorage.setItem('apiKey', apiKeyInput.value); // Save potentially updated key
                    localStorage.setItem('theme', isDark ? 'dark' : 'light');
                    localStorage.setItem('lang', isPersian ? 'fa' : 'en');
                    localStorage.setItem('personas', JSON.stringify(personas));
                    localStorage.setItem('prompts', JSON.stringify(prompts));
                    localStorage.setItem('currentPersonaPrompt', currentPersonaPrompt);
                } catch (e) {
                    console.error("Error saving state:", e);
                    // Display a non-blocking error?
                    // addToastNotification("Error saving state", "error");
                }
            }

            function getBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

             // --- PDF Text Extraction ---
            async function extractPdfText(file) {
                // Show processing state
                isProcessingFile = true;
                setInputsDisabled(true);
                addToastNotification(isPersian ? `ÿØÿ± ÿ≠ÿßŸÑ Ÿæÿ±ÿØÿßÿ≤ÿ¥ ${file.name}...` : `Processing ${file.name}...`, "info");

                try {
                    if (!window.pdfjsLib) throw new Error("PDF library not loaded");
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    let textContent = '';
                    const maxPages = pdf.numPages; // Limit pages if needed pdf.numPages
                    for (let i = 1; i <= maxPages; i++) {
                        const page = await pdf.getPage(i);
                        const text = await page.getTextContent();
                        textContent += text.items.map(item => item.str).join(' ') + '\n';
                        if (i % 10 === 0) console.log(`Extracted text from page ${i}/${maxPages}`);
                    }
                    console.log(`PDF text extraction complete. Length: ${textContent.length}`);
                    // Truncate based on estimated token limits. This is a rough estimate.
                    const MAX_CHARS = 15000; // Adjust as needed
                    if (textContent.length > MAX_CHARS) {
                        console.warn(`PDF text truncated from ${textContent.length} to ${MAX_CHARS} characters.`);
                        textContent = textContent.substring(0, MAX_CHARS) + "\n\n[... content truncated ...]";
                    }
                    addToastNotification(isPersian ? `Ÿæÿ±ÿØÿßÿ≤ÿ¥ ${file.name} ⁄©ÿßŸÖŸÑ ÿ¥ÿØ.` : `Finished processing ${file.name}.`, "success");
                    return textContent;
                } catch (error) {
                    console.error('Error extracting PDF text:', error);
                    addToastNotification(isPersian ? 'ÿÆÿ∑ÿß ÿØÿ± ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ŸÖÿ™ŸÜ PDF' : 'Error extracting PDF text', "error");
                    throw error; // Re-throw to be caught by caller
                } finally {
                    isProcessingFile = false;
                    setInputsDisabled(false); // Re-enable inputs after processing
                    chatInput.focus();
                }
            }

            // --- Plain Text Extraction ---
            async function extractPlainText(file) {
                 isProcessingFile = true;
                 setInputsDisabled(true);
                 addToastNotification(isPersian ? `ÿØÿ± ÿ≠ÿßŸÑ ÿÆŸàÿßŸÜÿØŸÜ ${file.name}...` : `Reading ${file.name}...`, "info");
                 return new Promise((resolve, reject) => {
                     const reader = new FileReader();
                     reader.readAsText(file);
                     reader.onload = () => {
                         let textContent = reader.result;
                          const MAX_CHARS = 20000; // Adjust as needed
                          if (textContent.length > MAX_CHARS) {
                              console.warn(`Text file truncated from ${textContent.length} to ${MAX_CHARS} characters.`);
                              textContent = textContent.substring(0, MAX_CHARS) + "\n\n[... content truncated ...]";
                          }
                         addToastNotification(isPersian ? `ÿÆŸàÿßŸÜÿØŸÜ ${file.name} ⁄©ÿßŸÖŸÑ ÿ¥ÿØ.` : `Finished reading ${file.name}.`, "success");
                         isProcessingFile = false;
                         setInputsDisabled(false);
                         chatInput.focus();
                         resolve(textContent);
                    };
                     reader.onerror = error => {
                         addToastNotification(isPersian ? 'ÿÆÿ∑ÿß ÿØÿ± ÿÆŸàÿßŸÜÿØŸÜ ŸÅÿß€åŸÑ ŸÖÿ™ŸÜ€å' : 'Error reading text file', "error");
                         isProcessingFile = false;
                         setInputsDisabled(false);
                         chatInput.focus();
                         reject(error);
                     };
                 });
            }

            // --- Simple Toast Notification ---
            function addToastNotification(message, type = "info") {
                 const toast = document.createElement('div');
                 toast.className = `toast toast-${type}`; // Add classes for styling
                 toast.textContent = message;
                 // Add styling for toast here or via CSS classes
                 toast.style.position = 'fixed';
                 toast.style.bottom = '80px'; // Above footer
                 toast.style.left = '50%';
                 toast.style.transform = 'translateX(-50%)';
                 toast.style.padding = '10px 20px';
                 toast.style.borderRadius = '5px';
                 toast.style.zIndex = '200';
                 toast.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
                 toast.style.opacity = '0.9';
                 toast.style.transition = 'opacity 0.5s ease-out';

                 if (type === 'error') toast.style.backgroundColor = '#dc3545'; // Red
                 else if (type === 'success') toast.style.backgroundColor = '#198754'; // Green
                 else toast.style.backgroundColor = '#0d6efd'; // Blue (info)
                 toast.style.color = 'white';

                 document.body.appendChild(toast);
                 setTimeout(() => {
                     toast.style.opacity = '0';
                     setTimeout(() => {
                         if (toast.parentNode) {
                            document.body.removeChild(toast);
                         }
                     }, 500); // Wait for fade out before removing
                 }, 3000); // Display for 3 seconds
            }


            // --- Send Message ---
            async function sendMessage(retryUserMessage = null) {
                if ((isTyping || isProcessingFile) && !retryUserMessage) {
                    console.warn("Attempted to send message while busy.");
                    return;
                }

                apiKey = apiKeyInput.value.trim();
                const messageText = retryUserMessage ? retryUserMessage.content.find(p=>p.type==='text')?.text : chatInput.value.trim();
                const fileToSend = retryUserMessage ? null : attachedFileInfo; // Use the pre-processed file info

                if (!apiKey) {
                    addMessageElement(createMessageObject(isPersian ? 'ŸÑÿ∑ŸÅÿßŸã ⁄©ŸÑ€åÿØ API ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.' : 'Please enter API key.', 'assistant'));
                    apiKeyInput.focus();
                    return;
                }
                // Ensure there's text OR a file OR it's a retry
                if (!messageText && !fileToSend && !retryUserMessage) {
                    return; // Nothing to send
                }

                // --- Abort Previous Stream ---
                if(currentAbortController) {
                    console.log("Aborting previous stream...");
                    currentAbortController.abort();
                    // Reset typing state immediately if aborting
                    isTyping = false;
                    setInputsDisabled(false);
                }
                currentAbortController = new AbortController();

                isTyping = true; // Mark as busy *before* async operations
                setInputsDisabled(true);

                let userMessage;
                let requiresVisionModel = false;
                let modelId = 'google/gemma-3-27b-it:free'; // Default model


                // --- Prepare User Message Object ---
                 if (retryUserMessage) {
                     userMessage = retryUserMessage;
                     // Check if the message being retried involved an image
                     if(userMessage.content.some(p => p.type === 'image_url')) {
                         requiresVisionModel = true;
                         modelId = 'google/gemini-pro-vision'; // Ensure vision model for retry
                     }
                 } else {
                     let fileDataForMessage = null;

                     if (fileToSend) {
                         fileDataForMessage = fileToSend; // Use pre-processed file info
                         if (fileToSend.type.startsWith('image/')) {
                             requiresVisionModel = true;
                             modelId = 'google/gemini-pro-vision';
                         }
                         // Clear the attached file state *after* creating the message object
                         attachedFileInfo = null;
                         updateInputPlaceholder();
                     }
                     // Create the new message object
                     userMessage = createMessageObject(messageText || (fileToSend ? (isPersian ? `ÿØÿ±ÿ®ÿßÿ±Ÿá ${fileToSend.name} ÿ®Ÿæÿ±ÿ≥` : `Ask about ${fileToSend.name}`) : ""), 'user', fileDataForMessage);
                     conversation.push(userMessage);
                     addMessageElement(userMessage); // Add to UI
                     chatInput.value = ''; // Clear input field
                 }


                saveState(); // Save conversation with new user message or just before retry


                 // --- Prepare API Payload ---
                 const MAX_CONTEXT_MESSAGES = 15; // Number of recent messages to include (adjust as needed)
                 const pinnedMessages = conversation.filter(msg => msg.pinned);
                 const recentMessages = conversation.filter(msg => !msg.pinned).slice(-MAX_CONTEXT_MESSAGES);

                 // Combine pinned and recent, removing duplicates, keeping latest occurrence
                 const messagesForContext = [...new Map([...pinnedMessages, ...recentMessages].map(item => [item.id, item])).values()];

                 const messagesToSend = messagesForContext.map(msg => ({ role: msg.role, content: msg.content }));

                if (currentPersonaPrompt) {
                    messagesToSend.unshift({ role: 'system', content: [{ type: 'text', text: currentPersonaPrompt }] });
                }


                // Add thinking indicator
                const thinkingIndicator = addThinking();


                // --- API Call (Streaming) ---
                let assistantResponseId = generateMessageId();
                let assistantMessageElement = null;


                try {
                    console.log(`Sending to model: ${modelId}`);
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.origin,
                            'X-Title': 'Gemma Chat PWA Enhanced V2',
                        },
                        body: JSON.stringify({
                            model: modelId,
                            messages: messagesToSend,
                            stream: true,
                        }),
                        signal: currentAbortController.signal,
                    });

                     removeThinking(thinkingIndicator);

                    if (!response.ok || !response.body) {
                        let errorDetails = `API Error (${response.status})`;
                         try { const errorData = await response.json(); errorDetails += `: ${errorData.error?.message || response.statusText}`; }
                         catch (e) { try { errorDetails += `: ${await response.text()}`; } catch (et) {} }
                        throw new Error(errorDetails);
                    }

                    // Process the stream
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let firstChunkReceived = false;

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        let boundary = buffer.indexOf('\n\n');

                        while(boundary >= 0) {
                             const message = buffer.substring(0, boundary);
                             buffer = buffer.substring(boundary + 2);
                             boundary = buffer.indexOf('\n\n');

                             if (message.startsWith('data: ')) {
                                 const dataContent = message.substring(6).trim();
                                 if (dataContent === '[DONE]') {
                                     // Final update handled after loop now
                                     continue;
                                 }
                                 try {
                                     const chunk = JSON.parse(dataContent);
                                     const delta = chunk.choices?.[0]?.delta?.content;
                                     if (delta) {
                                         if (!firstChunkReceived) {
                                              // First chunk: create message object and element
                                              const aiMsgObj = createMessageObject("", 'assistant', null, assistantResponseId);
                                              conversation.push(aiMsgObj); // Add placeholder to history
                                              assistantMessageElement = addMessageElement(aiMsgObj); // Add div to UI
                                              firstChunkReceived = true;
                                         }
                                         // Update DOM and state via updateStreamingMessage
                                         updateStreamingMessage(assistantResponseId, delta, false);
                                     }
                                 } catch (e) {
                                     console.error('Error parsing stream chunk:', e, 'Data:', dataContent);
                                 }
                             }
                        } // end while boundary
                    } // end while true reader

                    // After stream finishes (loop ends)
                    if (firstChunkReceived) {
                        // Ensure final update call to finalize rendering and state
                        updateStreamingMessage(assistantResponseId, '', true);
                    } else {
                        // Stream finished without sending any data chunks
                        console.warn("Stream finished without content.");
                        isTyping = false; // Reset typing flag
                        setInputsDisabled(false);
                        chatInput.focus();
                    }


                } catch (error) {
                     removeThinking(thinkingIndicator); // Ensure removed on error
                    if (error.name === 'AbortError') {
                         console.log('Fetch aborted by user.');
                         // Remove the potentially partially created assistant message object and element
                         const partialMsgIndex = conversation.findIndex(m => m.id === assistantResponseId);
                         if(partialMsgIndex > -1) conversation.splice(partialMsgIndex, 1);
                         const partialMsgDiv = chatBody.querySelector(`div[data-message-id="${assistantResponseId}"]`);
                         if(partialMsgDiv) chatBody.removeChild(partialMsgDiv);
                         saveState(); // Save state after removing aborted message
                         isTyping = false; // Was reset earlier on abort signal
                         setInputsDisabled(false);
                    } else {
                        console.error("API Stream Error:", error);
                        addMessageElement(createMessageObject(isPersian ? `ÿÆÿ∑ÿß: ${error.message}` : `Error: ${error.message}`, 'assistant'));
                        isTyping = false; // Reset typing on error
                        setInputsDisabled(false);
                    }
                } finally {
                    // isTyping and setInputsDisabled are handled within the stream logic or error handlers now
                    currentAbortController = null; // Clear controller after fetch completes or fails
                     // chatInput.focus(); // Focus might happen too early if stream was long
                }
            } // end sendMessage

            function setInputsDisabled(disabled) {
                 sendBtn.disabled = disabled;
                 chatInput.disabled = disabled;
                 fileBtn.disabled = disabled;
                 apiKeyInput.disabled = disabled;
                 personaSelect.disabled = disabled;
                 clearBtn.disabled = disabled; // Disable clear while busy
            }

            // --- Inline Action Handlers ---
            function handleCopyCodeClick(event) {
                const button = event.target;
                const pre = button.closest('pre');
                const code = pre?.querySelector('code');
                if (code) {
                    navigator.clipboard.writeText(code.textContent).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                             button.classList.remove('copied');
                        }, 1500);
                    }).catch(err => {
                        console.error('Failed to copy code:', err);
                        addToastNotification("Failed to copy code", "error");
                    });
                }
            }
             function handleCopyMessage(messageId) {
                 const msg = conversation.find(m => m.id === messageId);
                 const textToCopy = msg?.content?.find(p => p.type === 'text')?.text;
                 if(textToCopy) {
                     navigator.clipboard.writeText(textToCopy)
                       .then(() => addToastNotification("Message copied", "success"))
                       .catch(err => {
                            console.error('Failed to copy message:', err);
                            addToastNotification("Failed to copy message", "error");
                       });
                 }
             }
             function handlePinMessage(messageId) {
                 const msgIndex = conversation.findIndex(m => m.id === messageId);
                 if (msgIndex > -1) {
                     conversation[msgIndex].pinned = !conversation[msgIndex].pinned;
                     saveState();
                     // Update UI
                     const msgDiv = chatBody.querySelector(`div[data-message-id="${messageId}"]`);
                     const pinBtn = msgDiv?.querySelector('.pin-btn');
                     if (msgDiv && pinBtn) {
                         msgDiv.classList.toggle('pinned', conversation[msgIndex].pinned);
                         pinBtn.textContent = conversation[msgIndex].pinned ? 'üìå' : 'üìç';
                         pinBtn.title = conversation[msgIndex].pinned ? (isPersian ? 'ÿ®ÿ±ÿØÿßÿ¥ÿ™ŸÜ ÿ≥ŸÜÿ¨ÿßŸÇ' : 'Unpin') : (isPersian ? 'ÿ≥ŸÜÿ¨ÿßŸÇ ⁄©ÿ±ÿØŸÜ' : 'Pin');
                     }
                 }
             }
             function handleRetryMessage(messageId) {
                 if (isTyping || isProcessingFile) return; // Don't allow retry if already busy

                 const aiMsgIndex = conversation.findIndex(m => m.id === messageId);
                 if(aiMsgIndex > 0) {
                    let userMsgIndex = -1;
                    for(let i = aiMsgIndex - 1; i >= 0; i--) {
                        if(conversation[i].role === 'user') {
                            userMsgIndex = i;
                            break;
                        }
                    }
                    if(userMsgIndex > -1) {
                        const userMessageToRetry = conversation[userMsgIndex];
                        // Remove the AI message being retried and any subsequent messages for a clean retry
                         conversation.splice(aiMsgIndex);
                         // Reload UI to reflect removed messages
                         chatBody.innerHTML = '';
                         conversation.forEach(msg => addMessageElement(msg, false));
                         scrollToBottom(true); // Instant scroll after reload

                         console.log("Retrying user message:", userMessageToRetry.id);
                         sendMessage(userMessageToRetry); // Pass the user message object to resend
                    } else {
                         console.error("Could not find preceding user message to retry.");
                         addToastNotification("Cannot find message to retry", "error");
                    }
                 }
             }
             function handleReadAloud(messageId) {
                const msg = conversation.find(m => m.id === messageId);
                const textToRead = msg?.content?.find(p => p.type === 'text')?.text;
                 if (textToRead && 'speechSynthesis' in window) {
                     window.speechSynthesis.cancel(); // Cancel previous speech
                     const utterance = new SpeechSynthesisUtterance(textToRead);
                     // Basic language setting (might need more sophisticated detection)
                     utterance.lang = isPersian ? 'fa-IR' : 'en-US';
                     window.speechSynthesis.speak(utterance);
                 } else if (!('speechSynthesis' in window)) {
                     console.warn("Speech Synthesis not supported.");
                     addToastNotification("Speech synthesis not supported", "error");
                 }
             }

             // --- Search Handler ---
            let searchDebounceTimer;
            function handleSearch() {
                clearTimeout(searchDebounceTimer);
                searchDebounceTimer = setTimeout(() => {
                    const searchTerm = searchInput.value.toLowerCase().trim();
                    const messages = chatBody.querySelectorAll('.message');
                    let firstMatch = null;
                    messages.forEach(msgDiv => {
                        const contentDiv = msgDiv.querySelector('.message-content');
                        if (contentDiv) {
                             const msgText = contentDiv.textContent.toLowerCase();
                             if (searchTerm && msgText.includes(searchTerm)) {
                                 msgDiv.classList.add('search-highlight');
                                 if (!firstMatch) firstMatch = msgDiv; // Find the first match
                             } else {
                                 msgDiv.classList.remove('search-highlight');
                             }
                        }
                    });
                    // Scroll to the first match if found
                    if(firstMatch) {
                        firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 300); // Debounce search for 300ms
            }

             // --- Prompt Library Handlers ---
            function openPromptModal() {
                 populatePromptList();
                 promptModal.classList.add('active');
            }
            function closePromptModal() {
                 promptModal.classList.remove('active');
                 newPromptNameInput.value = '';
                 newPromptTextInput.value = '';
            }
            function populatePromptList() {
                 promptListUl.innerHTML = ''; // Clear list
                 prompts.forEach((prompt, index) => {
                     const li = document.createElement('li');
                     li.className = 'prompt-item';
                     li.innerHTML = `
                         <span data-index="${index}" title="${prompt.text}">${prompt.name}</span>
                         <button data-index="${index}" title="Delete Prompt">√ó</button>
                     `;
                     promptListUl.appendChild(li);
                 });
                 // Add listeners after population
                 promptListUl.querySelectorAll('span').forEach(span => {
                     span.addEventListener('click', handleUsePrompt);
                 });
                 promptListUl.querySelectorAll('button').forEach(button => {
                     button.addEventListener('click', handleDeletePrompt);
                 });
            }
            async function handleUsePrompt(event) { // Make async for clipboard
                 const index = parseInt(event.target.dataset.index);
                 if (!isNaN(index) && prompts[index]) {
                     let textToInsert = prompts[index].text;
                     // Placeholder replacement
                     try {
                         if(textToInsert.includes('{clipboard}')) {
                             const clipText = await navigator.clipboard.readText();
                             textToInsert = textToInsert.replace('{clipboard}', clipText || '');
                         }
                         if (textToInsert.includes('{selection}')) {
                              // Try to get text selection (might not work reliably across browsers/contexts)
                              const selection = window.getSelection()?.toString() || '';
                              textToInsert = textToInsert.replace('{selection}', selection);
                         }
                     } catch (err) {
                         console.warn("Clipboard or selection access failed:", err);
                         textToInsert = textToInsert.replace('{clipboard}', '').replace('{selection}', ''); // Remove placeholders if failed
                     }
                     chatInput.value = textToInsert;
                     chatInput.focus();
                     closePromptModal();
                 }
            }
             function handleSavePrompt() {
                 const name = newPromptNameInput.value.trim();
                 const text = newPromptTextInput.value.trim();
                 if (name && text) {
                     // Check for duplicate name?
                     if (prompts.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                         alert(isPersian ? "ŸÜÿßŸÖ ÿßÿπŸÑÿßŸÜ ÿ™⁄©ÿ±ÿßÿ±€å ÿßÿ≥ÿ™." : "Prompt name already exists.");
                         return;
                     }
                     prompts.push({ name, text });
                     saveState();
                     populatePromptList();
                     newPromptNameInput.value = '';
                     newPromptTextInput.value = '';
                     addToastNotification("Prompt saved", "success");
                 } else {
                      alert(isPersian ? "ŸÑÿ∑ŸÅÿß ŸÜÿßŸÖ Ÿà ŸÖÿ™ŸÜ ÿßÿπŸÑÿßŸÜ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ." : "Please enter both prompt name and text.");
                 }
            }
            function handleDeletePrompt(event) {
                 const index = parseInt(event.target.dataset.index);
                 if (!isNaN(index) && prompts[index]) {
                      if (confirm(`${isPersian ? "ÿ¢€åÿß ŸÖÿ∑ŸÖÿ¶ŸÜ Ÿáÿ≥ÿ™€åÿØ ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿß€åŸÜ ÿßÿπŸÑÿßŸÜ ÿ±ÿß ÿ≠ÿ∞ŸÅ ⁄©ŸÜ€åÿØ:" : "Are you sure you want to delete this prompt:"}\n\n${prompts[index].name}`)) {
                         prompts.splice(index, 1);
                         saveState();
                         populatePromptList();
                         addToastNotification("Prompt deleted", "info");
                     }
                 }
            }

             // --- File Handling ---
            function handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) {
                    attachedFileInfo = null;
                    updateInputPlaceholder();
                    return;
                }
                 // Store basic file info immediately for placeholder update
                 attachedFileInfo = {
                     name: file.name,
                     size: file.size,
                     type: file.type,
                     // Placeholders for processed data
                     base64Data: null,
                     extractedText: null
                 };
                 updateInputPlaceholder();

                 // Process the file asynchronously (don't block UI thread)
                 processSelectedFile(file);
            }

            async function processSelectedFile(file) {
                // Reset previous processed data
                if (attachedFileInfo) {
                     attachedFileInfo.base64Data = null;
                     attachedFileInfo.extractedText = null;
                } else { return; } // Should not happen if called from handleFileSelect

                try {
                    if (file.type.startsWith('image/')) {
                        attachedFileInfo.base64Data = await getBase64(file);
                        console.log("Image processed for sending.");
                    } else if (file.type === 'application/pdf') {
                        attachedFileInfo.extractedText = await extractPdfText(file); // This now handles notifications/state
                    } else if (file.type === 'text/plain') {
                        attachedFileInfo.extractedText = await extractPlainText(file); // This now handles notifications/state
                    } else {
                         addToastNotification(`Unsupported file type: ${file.type}`, "error");
                         attachedFileInfo = null; // Invalidate unsupported file
                         updateInputPlaceholder();
                    }
                } catch (error) {
                    console.error("Error processing file:", error);
                    addToastNotification(`Error processing file: ${error.message}`, "error");
                    attachedFileInfo = null; // Invalidate on error
                    updateInputPlaceholder();
                }
            }

            function updateInputPlaceholder() {
                if (attachedFileInfo) {
                    chatInput.placeholder = isPersian ? `ÿØÿ±ÿ®ÿßÿ±Ÿá ${attachedFileInfo.name} ÿ®Ÿæÿ±ÿ≥€åÿØ...` : `Ask about ${attachedFileInfo.name}...`;
                } else {
                     chatInput.placeholder = isPersian ? "Ÿæ€åÿßŸÖ ÿÆŸàÿØ ÿ±ÿß ÿ™ÿß€åŸæ ⁄©ŸÜ€åÿØ..." : "Type your message...";
                }
            }


            // --- Event Listeners ---
            sendBtn.addEventListener('click', () => sendMessage());
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
            });

            fileBtn.addEventListener('click', () => { fileInput.click(); });
            fileInput.addEventListener('change', handleFileSelect); // Use dedicated handler

            clearBtn.addEventListener('click', () => {
                if (isTyping || isProcessingFile) return; // Don't clear while busy
                if (confirm(isPersian ? "Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ⁄©ŸÑ ÿ™ÿßÿ±€åÿÆ⁄ÜŸá ⁄Üÿ™ÿü" : "Clear entire chat history?")) {
                     conversation = []; chatBody.innerHTML = '';
                     localStorage.removeItem('conversation_v2'); saveState();
                     if(window.speechSynthesis) window.speechSynthesis.cancel();
                     attachedFileInfo = null; updateInputPlaceholder(); // Clear attached file state
                     addToastNotification("Chat cleared", "info");
                }
            });
            themeBtn.addEventListener('click', () => {
                isDark = !isDark; updateUI(); saveState();
            });
            langBtn.addEventListener('click', () => {
                isPersian = !isPersian; updateUI(); saveState();
            });
            apiBtn.addEventListener('click', () => {
                window.open('https://openrouter.ai/settings/keys', '_blank', 'noopener noreferrer');
            });
            searchInput.addEventListener('input', handleSearch);
            personaSelect.addEventListener('change', (e) => {
                currentPersonaPrompt = e.target.value;
                localStorage.setItem('currentPersonaPrompt', currentPersonaPrompt);
                 addToastNotification(`Persona set to: ${e.target.options[e.target.selectedIndex].text}`, "info");
            });

            // Prompt Library Modal Listeners
             promptLibraryBtn.addEventListener('click', openPromptModal);
             closeModalBtn.addEventListener('click', closePromptModal);
             savePromptBtn.addEventListener('click', handleSavePrompt);
             promptModal.addEventListener('click', (e) => { // Close if clicking outside modal content
                 if (e.target === promptModal) { closePromptModal(); }
             });


            // --- Initialization ---
            window.addEventListener('load', () => {
                loadConversation();

                 // Register Service Worker for Offline Caching
                 if ('serviceWorker' in navigator) {
                     navigator.serviceWorker.register('./service-worker.js')
                         .then(registration => console.log('Service Worker registered with scope:', registration.scope))
                         .catch(error => console.error('Service Worker registration failed:', error));
                 } else {
                    console.warn('Service Worker not supported in this browser.');
                 }
            });

             // Stop speech synthesis when page is unloaded
             window.addEventListener('beforeunload', () => {
                 if (window.speechSynthesis) {
                     window.speechSynthesis.cancel();
                 }
             });

        })();
    </script>

</body>
</html>
