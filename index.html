<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <title>Gemma Chat</title>
    <style>
        /* --- General Reset & Base Styles --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            height: 100%; /* Ensure html takes full height */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh; /* Use min-height for flexibility */
            display: flex;
            justify-content: center;
            align-items: center;
            background: #e9ecef;
            transition: background 0.3s ease;
            padding: 10px; /* Padding for small screens / edges */
            line-height: 1.4; /* Base line-height */
        }

        /* --- Theme: Dark Mode --- */
        body.dark {
            background: #212529;
            color: #f8f9fa; /* Set base dark mode text color */
        }

        .dark .chat-wrapper {
            background: #343a40;
            color: #f8f9fa;
        }

        .dark .chat-header,
        .dark .api-section {
            border-bottom-color: #495057;
        }

        .dark .chat-footer {
            border-top-color: #495057;
            background: #343a40;
        }

        .dark .ai-msg {
            background: #495057;
            color: #f8f9fa;
            border-color: #6c757d;
        }

        .dark .ai-msg code {
            background: #6c757d;
        }

        .dark input[type="text"],
        .dark #api-key-input {
            background: #495057;
            color: #f8f9fa;
            border-color: #6c757d;
        }

        /* --- Layout: Chat Wrapper --- */
        .chat-wrapper {
            width: 90%;
            max-width: 800px;
            height: 75vh; /* Adjusted height for better fit */
            max-height: 800px; /* Added max-height */
            background: #ffffff;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background 0.3s ease, color 0.3s ease;
        }

        /* --- Components: Header --- */
        .chat-header {
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 8px; /* Slightly increased gap */
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .chat-header h1 {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap; /* Allow controls to wrap */
        }

        /* --- Components: API Key Section --- */
        .api-section {
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            gap: 5px;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping */
            flex-shrink: 0; /* Prevent section from shrinking */
        }

        /* --- Components: Chat Body & Messages --- */
        .chat-body {
            flex-grow: 1; /* Allow body to take available space */
            padding: 15px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 80%;
            line-height: 1.4;
            animation: fadeIn 0.3s ease;
            font-size: 0.9rem;
            word-wrap: break-word; /* Ensure long words break */
        }

        .user-msg {
            background: #0d6efd;
            color: #fff;
            margin-left: auto;
            text-align: right; /* Align user text right */
        }

        .ai-msg {
            background: #f1f3f5;
            color: #212529;
            border: 1px solid #dee2e6;
            margin-right: auto; /* Ensure AI messages align left */
            text-align: left; /* Align AI text left */
        }

        /* Markdown Styles within AI messages */
        .ai-msg p:last-child {
            margin-bottom: 0; /* Remove bottom margin from last paragraph */
        }
        .ai-msg p { margin: 0 0 8px; }
        .ai-msg ul,
        .ai-msg ol { margin: 0 0 8px 20px; padding-left: 10px;} /* Added padding-left */
        .ai-msg li { margin: 4px 0; }
        .ai-msg strong { font-weight: 700; }
        .ai-msg em { font-style: italic; }
        .ai-msg code {
            background: #e9ecef;
            padding: 2px 4px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace; /* Consistent monospace font */
            font-size: 0.85em; /* Slightly smaller code font */
        }
        .ai-msg pre { /* Style for code blocks */
             background: #e9ecef;
             padding: 8px;
             border-radius: 4px;
             overflow-x: auto;
             margin: 8px 0;
        }
        .dark .ai-msg pre {
             background: #6c757d;
        }
         .ai-msg pre code { /* Reset code style inside pre */
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 1em; /* Inherit font size from pre */
         }


        /* Thinking Indicator */
        .thinking {
            display: flex;
            align-items: center; /* Vertically align dots */
            gap: 5px;
            padding: 8px 12px; /* Match message padding */
            margin: 8px 0; /* Match message margin */
            max-width: fit-content; /* Size to content */
            margin-right: auto; /* Align left like AI messages */
        }

        .dot {
            width: 6px;
            height: 6px;
            background: #0d6efd;
            border-radius: 50%;
            animation: bounce 1.2s infinite ease-in-out; /* Added ease-in-out */
        }
        .dot:nth-child(2) { animation-delay: 0.15s; } /* Adjusted delay */
        .dot:nth-child(3) { animation-delay: 0.3s; } /* Adjusted delay */

        /* --- Components: Footer --- */
        .chat-footer {
            padding: 10px 15px;
            border-top: 1px solid #dee2e6;
            background: #ffffff;
            display: flex;
            gap: 5px;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping */
            flex-shrink: 0; /* Prevent footer from shrinking */
        }

        /* --- Components: Inputs & Buttons --- */
        input[type="text"],
        #api-key-input {
            flex: 1; /* Take available space */
            padding: 8px 10px; /* Adjusted padding */
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease; /* Added box-shadow transition */
            min-width: 100px; /* Minimum width to prevent excessive shrinking */
            height: 36px; /* Fixed height for alignment */
        }

        input:focus,
        #api-key-input:focus {
            outline: none;
            border-color: #0d6efd;
            box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.25); /* Focus ring */
        }

        button {
            padding: 0 12px; /* Adjusted padding for consistent height */
            height: 36px; /* Match input height */
            background: #0d6efd;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500; /* Slightly bolder button text */
            transition: background 0.2s ease, transform 0.2s ease;
            display: inline-flex; /* Align icon/text nicely if needed */
            align-items: center;
            justify-content: center;
            min-width: 60px;
        }

        button:hover {
            background: #0a58ca;
            transform: translateY(-1px); /* Subtle hover effect */
        }
        button:active {
             transform: translateY(0); /* Remove lift on click */
        }

        #clear-btn { background: #dc3545; }
        #clear-btn:hover { background: #bb2d3b; }

        #api-btn { background: #198754; }
        #api-btn:hover { background: #157347; }

        #file-btn {
            background: #6c757d;
            min-width: 36px; /* Make it square-ish */
            padding: 0; /* Remove padding as it's fixed size */
            font-size: 1.2rem; /* Make icon slightly larger */
            line-height: 1; /* Adjust line height for icon */
        }
        #file-btn:hover { background: #5c636a; }

        #file-input { display: none; }

        /* --- Utilities: RTL Support --- */
        .rtl { direction: rtl; }
        .rtl .message {
            margin-left: 0;
            margin-right: auto;
            text-align: right; /* Default text align for RTL */
        }
        .rtl .user-msg {
            margin-right: auto; /* User messages align left in RTL */
            margin-left: 0;
            text-align: left;
        }
         .rtl .ai-msg {
            margin-left: auto; /* AI messages align right in RTL */
            margin-right: 0;
            text-align: right;
         }
         .rtl .thinking {
             margin-left: auto;
             margin-right: 0;
         }


        /* --- Media Queries for Mobile --- */
        @media (max-width: 768px) {
            body {
                padding: 5px; /* Less padding on mobile */
                height: -webkit-fill-available; /* Fix height on mobile safari */
                min-height: -webkit-fill-available;
            }

            .chat-wrapper {
                width: 100%;
                height: 100%; /* Full height/width on mobile */
                max-height: none; /* Remove max-height */
                border-radius: 0; /* Edge-to-edge */
                box-shadow: none;
            }

            .chat-header {
                padding: 8px 10px;
            }
            .chat-header h1 {
                font-size: 1rem;
            }

            .chat-body {
                padding: 10px;
            }

            .message {
                font-size: 0.85rem;
                padding: 6px 10px;
                max-width: 85%;
            }

            .api-section,
            .chat-footer {
                padding: 8px 10px;
                /* Keep flex-wrap: wrap, but don't force column */
            }

            input[type="text"],
            #api-key-input {
                font-size: 0.85rem;
                padding: 6px 8px;
                height: 34px; /* Slightly smaller height */
            }

            button {
                font-size: 0.85rem;
                padding: 0 10px;
                height: 34px; /* Match input */
                min-width: 50px;
            }

            #file-btn {
                min-width: 34px; /* Match height */
                font-size: 1rem;
            }

            .controls {
                gap: 3px;
            }
        }

        /* --- Animations --- */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }

    </style>
</head>
<body class="${localStorage.getItem('theme') === 'dark' ? 'dark' : ''}">

    <!-- Main Chat Application Wrapper -->
    <div class="chat-wrapper">

        <!-- Chat Header: Title and Controls -->
        <div class="chat-header">
            <h1 data-en="Gemma Chat" data-fa="Ú†Øª Ù†ÙˆØ§">Gemma Chat</h1>
            <div class="controls">
                <button id="theme-btn" data-en="Dark" data-fa="ØªØ§Ø±ÛŒÚ©">
                    ${localStorage.getItem('theme') === 'dark' ? (localStorage.getItem('lang') === 'fa' ? 'Ø±ÙˆØ´Ù†' : 'Light') : (localStorage.getItem('lang') === 'fa' ? 'ØªØ§Ø±ÛŒÚ©' : 'Dark')}
                </button>
                <button id="lang-btn" data-en="Persian" data-fa="Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ">
                    ${localStorage.getItem('lang') === 'fa' ? 'Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ' : 'Persian'}
                </button>
                <button id="clear-btn" data-en="Clear Chat" data-fa="Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ú†Øª">Clear Chat</button>
            </div>
        </div>

        <!-- API Key Input Section -->
        <div class="api-section">
            <input type="text" id="api-key-input"
                   placeholder="Enter OpenRouter API Key"
                   data-en-placeholder="Enter OpenRouter API Key"
                   data-fa-placeholder="Ú©Ù„ÛŒØ¯ API OpenRouter Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"
                   value="${localStorage.getItem('apiKey') || ''}">
            <button id="api-btn" data-en="Get Key" data-fa="Ø¯Ø±ÛŒØ§ÙØª Ú©Ù„ÛŒØ¯">Get Key</button>
        </div>

        <!-- Chat Messages Area -->
        <div class="chat-body" id="chat-body">
            <!-- Messages will be loaded here -->
        </div>

        <!-- Chat Input Footer -->
        <div class="chat-footer">
            <input type="text" id="chat-input"
                   placeholder="Type your message..."
                   data-en-placeholder="Type your message..."
                   data-fa-placeholder="Ù¾ÛŒØ§Ù… Ø®ÙˆØ¯ Ø±Ø§ ØªØ§ÛŒÙ¾ Ú©Ù†ÛŒØ¯...">
            <button id="file-btn" title="Attach file">ðŸ“Ž</button>
            <button id="send-btn">Send</button>
            <input type="file" id="file-input" accept="image/*,application/pdf,text/plain">
        </div>

    </div><!-- /.chat-wrapper -->

    <script>
        // IIFE to encapsulate chat logic and avoid global scope pollution
        (function() {
            "use strict"; // Enable strict mode

            // --- State Variables ---
            let conversation = JSON.parse(localStorage.getItem('conversation')) || [];
            let apiKey = localStorage.getItem('apiKey') || '';
            let isTyping = false; // Flag to prevent multiple simultaneous requests
            let isDark = localStorage.getItem('theme') === 'dark';
            let isPersian = localStorage.getItem('lang') === 'fa';

            // --- DOM Element References ---
            const chatBody = document.getElementById('chat-body');
            const apiKeyInput = document.getElementById('api-key-input');
            const chatInput = document.getElementById('chat-input');
            const fileInput = document.getElementById('file-input');
            const themeBtn = document.getElementById('theme-btn');
            const langBtn = document.getElementById('lang-btn');
            const clearBtn = document.getElementById('clear-btn');
            const apiBtn = document.getElementById('api-btn');
            const sendBtn = document.getElementById('send-btn');
            const fileBtn = document.getElementById('file-btn');

            // --- Core Functions ---

            /**
             * Updates the UI based on the current theme and language settings.
             */
            function updateUI() {
                // Toggle dark theme class on body
                document.body.classList.toggle('dark', isDark);
                // Toggle RTL class on body for Persian language
                document.body.classList.toggle('rtl', isPersian);

                // Update text content based on language
                document.querySelectorAll('[data-en]').forEach(el => {
                    el.textContent = isPersian ? el.getAttribute('data-fa') : el.getAttribute('data-en');
                });

                // Update placeholder text based on language
                document.querySelectorAll('[data-en-placeholder]').forEach(el => {
                    el.placeholder = isPersian ? el.getAttribute('data-fa-placeholder') : el.getAttribute('data-en-placeholder');
                });

                // Update theme button text
                themeBtn.textContent = isDark
                    ? (isPersian ? 'Ø±ÙˆØ´Ù†' : 'Light')
                    : (isPersian ? 'ØªØ§Ø±ÛŒÚ©' : 'Dark');

                 // Update language button text
                langBtn.textContent = isPersian ? 'Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ' : 'Persian';

                // Ensure send button text updates immediately
                sendBtn.textContent = isPersian ? 'Ø§Ø±Ø³Ø§Ù„' : 'Send';
            }

            /**
             * Loads the conversation history from localStorage and renders messages.
             */
            function loadConversation() {
                chatBody.innerHTML = ''; // Clear existing messages
                conversation.forEach(msg => {
                    const isUser = msg.role === 'user';
                    // Handle potential variations in content structure gracefully
                    let displayContent = '[Message content unavailable]';
                    if (Array.isArray(msg.content) && msg.content.length > 0) {
                         const firstPart = msg.content[0];
                         if (firstPart.type === 'text') {
                             displayContent = firstPart.text;
                         } else if (firstPart.type === 'image_url') {
                             displayContent = isPersian ? '[ØªØµÙˆÛŒØ± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯]' : '[Image loaded]';
                         }
                         // Add more conditions if other types expected
                    } else if (typeof msg.content === 'string') { // Handle older format if necessary
                         displayContent = msg.content;
                    }
                    addMessage(displayContent, isUser, false); // Add message without animation on load
                });
                apiKeyInput.value = apiKey; // Set API key input value
                updateUI(); // Apply theme and language
                // Scroll to bottom after loading (give a slight delay for rendering)
                setTimeout(() => {
                     chatBody.scrollTop = chatBody.scrollHeight;
                }, 50);
            }

            /**
             * Adds a message bubble to the chat body.
             * @param {string} content - The message text or description.
             * @param {boolean} [isUser=false] - True if the message is from the user.
             * @param {boolean} [animate=true] - True to scroll the message into view.
             */
            function addMessage(content, isUser = false, animate = true) {
                const msgDiv = document.createElement('div');
                msgDiv.className = `message ${isUser ? 'user-msg' : 'ai-msg'}`;

                if (isUser) {
                    // For user messages, just set text content to avoid XSS risks if content isn't sanitized
                    msgDiv.textContent = content;
                } else {
                    // For AI messages, parse Markdown content
                    // Ensure marked is loaded before calling parse
                    if (typeof marked !== 'undefined') {
                         // Configure marked to add breaks for newlines
                         marked.setOptions({ breaks: true });
                         msgDiv.innerHTML = marked.parse(content || ''); // Use empty string if content is null/undefined
                    } else {
                         console.error("Marked library not loaded.");
                         msgDiv.textContent = content; // Fallback to text content
                    }
                }

                chatBody.appendChild(msgDiv);

                // Scroll to the bottom to show the new message
                if (animate) {
                     chatBody.scrollTop = chatBody.scrollHeight;
                }
            }

            /**
             * Adds a "thinking" animation to indicate the AI is processing.
             * @returns {HTMLElement} The thinking indicator element.
             */
            function addThinking() {
                // Remove existing thinking indicator if any
                 const existingThinking = chatBody.querySelector('.thinking');
                 if(existingThinking) {
                     removeThinking(existingThinking);
                 }

                const thinkingDiv = document.createElement('div');
                thinkingDiv.className = 'thinking ai-msg'; // Style like an AI message but with thinking class
                thinkingDiv.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
                chatBody.appendChild(thinkingDiv);
                chatBody.scrollTop = chatBody.scrollHeight; // Scroll to show indicator
                return thinkingDiv;
            }

            /**
             * Removes the thinking indicator element.
             * @param {HTMLElement} thinkingElement - The element to remove.
             */
            function removeThinking(thinkingElement) {
                if (thinkingElement && thinkingElement.parentNode === chatBody) {
                    chatBody.removeChild(thinkingElement);
                }
            }

            /**
             * Saves the current state (conversation, API key, theme, lang) to localStorage.
             */
            function saveState() {
                try {
                    localStorage.setItem('conversation', JSON.stringify(conversation));
                    localStorage.setItem('apiKey', apiKey);
                    localStorage.setItem('theme', isDark ? 'dark' : 'light');
                    localStorage.setItem('lang', isPersian ? 'fa' : 'en');
                } catch (e) {
                    console.error("Error saving state to localStorage:", e);
                    // Optionally notify the user that settings might not be saved
                    addMessage(isPersian ? "Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª Ú†Øª." : "Error saving chat state.", false);
                }
            }

            /**
             * Converts a file to a Base64 encoded string.
             * @param {File} file - The file to convert.
             * @returns {Promise<string>} A promise resolving with the Base64 data URL.
             */
            function getBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

            /**
             * Sends the user's message (text and/or file) to the OpenRouter API.
             * @param {File} [file=null] - An optional file to upload.
             */
            async function sendMessage(file = null) {
                if (isTyping) return; // Prevent concurrent requests

                apiKey = apiKeyInput.value.trim(); // Get current API key value
                const messageText = chatInput.value.trim();

                // --- Input Validation ---
                if (!apiKey) {
                    addMessage(isPersian ? 'Ù„Ø·ÙØ§Ù‹ Ú©Ù„ÛŒØ¯ API OpenRouter Ù…Ø¹ØªØ¨Ø± Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.' : 'Please enter your valid OpenRouter API key.', false);
                    return; // Stop if no API key
                }
                if (!messageText && !file) {
                    return; // Stop if no message text and no file
                }

                isTyping = true; // Set typing flag
                sendBtn.disabled = true; // Disable send button
                chatInput.disabled = true; // Disable text input
                fileBtn.disabled = true; // Disable file button

                const thinkingIndicator = addThinking(); // Show thinking indicator

                // --- Prepare Message Payload ---
                let currentMessageContent = [];
                let userDisplayMessage = ""; // What to show in the user's bubble

                // Handle text message part
                if (messageText) {
                    currentMessageContent.push({ type: 'text', text: messageText });
                    userDisplayMessage = messageText;
                    addMessage(messageText, true); // Add user text message immediately
                    chatInput.value = ''; // Clear input field
                }

                // Handle file part
                if (file) {
                    try {
                        const base64Data = await getBase64(file);
                        const fileType = file.type;
                        let fileDescription = "";

                        if (fileType.startsWith('image/')) {
                             currentMessageContent.push({ type: 'image_url', image_url: { url: base64Data } });
                             fileDescription = isPersian ? `[ØªØµÙˆÛŒØ± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯: ${file.name}]` : `[Image sent: ${file.name}]`;
                        } else if (fileType === 'application/pdf' || fileType === 'text/plain') {
                            // Note: Sending large file content directly in 'text' might exceed limits.
                            // This example sends the base64 data as text, which the model might not interpret well.
                            // A better approach might involve summarizing or extracting text first if possible.
                            // For now, we'll just indicate the file was "uploaded".
                            currentMessageContent.push({ type: 'text', text: `[User uploaded file: ${file.name}, type: ${fileType}]` }); // More informative text for the AI
                             fileDescription = isPersian ? `[ÙØ§ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯: ${file.name}]` : `[File sent: ${file.name}]`;
                        } else {
                            addMessage(isPersian ? `Ù†ÙˆØ¹ ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯: ${fileType}` : `Unsupported file type: ${fileType}`, false);
                            removeThinking(thinkingIndicator);
                            isTyping = false;
                            sendBtn.disabled = false;
                            chatInput.disabled = false;
                            fileBtn.disabled = false;
                            return; // Stop if file type is unsupported
                        }

                        // Add a combined message bubble if both text and file were sent, or just the file description
                        if (!messageText && fileDescription) {
                             addMessage(fileDescription, true);
                        } else if (messageText && fileDescription) {
                             // Message bubble already added for text, maybe add file info separately?
                             // Or update the existing user message? For simplicity, we'll rely on the text bubble.
                             console.log("File sent along with text message:", file.name);
                        }

                        fileInput.value = ''; // Clear the file input

                    } catch (error) {
                        console.error("File processing error:", error);
                        addMessage(isPersian ? `Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙØ§ÛŒÙ„: ${error.message}` : `File processing error: ${error.message}`, false);
                        removeThinking(thinkingIndicator);
                        isTyping = false;
                        sendBtn.disabled = false;
                        chatInput.disabled = false;
                        fileBtn.disabled = false;
                        return; // Stop on file error
                    }
                }

                // Add the complete user message structure to conversation history
                const userMsg = { role: 'user', content: currentMessageContent };
                conversation.push(userMsg);
                saveState(); // Save updated conversation

                // --- API Call ---
                try {
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            // Recommended headers for OpenRouter identification
                            'HTTP-Referer': window.location.href, // Replace with your actual site URL if deployed
                            'X-Title': 'Gemma Chat', // Replace with your app's name
                        },
                        body: JSON.stringify({
                            model: 'google/gemma-3-27b-it:free', // Or specify another model
                            messages: conversation, // Send the whole conversation history
                            // stream: false // Set to true for streaming responses (would require different handling)
                        }),
                    });

                    removeThinking(thinkingIndicator); // Remove indicator once response starts processing

                    if (!response.ok) {
                        // Try to parse error details from OpenRouter's response
                        let errorDetails = `API Error (${response.status})`;
                        try {
                            const errorData = await response.json();
                            errorDetails += `: ${errorData.error?.message || response.statusText}`;
                        } catch (jsonError) {
                            // Fallback if the error response isn't JSON
                            errorDetails += `: ${await response.text()}`;
                        }
                        throw new Error(errorDetails);
                    }

                    const data = await response.json();

                    // Extract AI response content
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        const aiContent = data.choices[0].message.content;
                        // Add AI response to chat and history
                        const aiMsg = { role: 'assistant', content: [{ type: 'text', text: aiContent }] }; // Assuming AI response is always text
                        conversation.push(aiMsg);
                        addMessage(aiContent, false); // Add AI message to display
                        saveState(); // Save updated conversation with AI response
                    } else {
                        throw new Error("Invalid response structure received from API.");
                    }

                } catch (error) {
                    console.error("API Request Error:", error);
                    removeThinking(thinkingIndicator); // Ensure indicator is removed on error
                    addMessage(isPersian ? `Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ Ø³Ø±ÙˆØ±: ${error.message}` : `Error communicating with server: ${error.message}`, false);
                } finally {
                    // --- Reset State ---
                    isTyping = false; // Reset typing flag
                    sendBtn.disabled = false; // Re-enable send button
                    chatInput.disabled = false; // Re-enable input
                    fileBtn.disabled = false; // Re-enable file button
                    chatInput.focus(); // Focus input for next message
                }
            }

            // --- Event Listeners ---

            // Send message on button click
            sendBtn.addEventListener('click', () => sendMessage());

            // Send message on Enter key press in input field
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { // Send on Enter, allow Shift+Enter for newline
                    e.preventDefault(); // Prevent default newline insertion
                    sendMessage();
                }
            });

            // Trigger file input click when file button is clicked
            fileBtn.addEventListener('click', () => {
                fileInput.click();
            });

            // Send message with file when a file is selected
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    sendMessage(file); // Call send message with the selected file
                }
            });

            // Clear chat history
            clearBtn.addEventListener('click', () => {
                if (confirm(isPersian ? "Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ú©Ù„ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ú†Øª Ø±Ø§ Ù¾Ø§Ú© Ú©Ù†ÛŒØ¯ØŸ" : "Are you sure you want to clear the entire chat history?")) {
                     conversation = []; // Clear conversation array
                     chatBody.innerHTML = ''; // Clear messages from UI
                     localStorage.removeItem('conversation'); // Remove from storage
                     // Optionally keep other settings like API key, theme, lang
                     saveState(); // Save the empty state (or just update storage)
                }
            });

            // Toggle theme
            themeBtn.addEventListener('click', () => {
                isDark = !isDark;
                updateUI();
                saveState();
            });

            // Toggle language
            langBtn.addEventListener('click', () => {
                isPersian = !isPersian;
                updateUI();
                saveState();
            });

            // Open OpenRouter keys page
            apiBtn.addEventListener('click', () => {
                window.open('https://openrouter.ai/settings/keys', '_blank', 'noopener noreferrer');
            });

            // --- Initialization ---
            // Load conversation and apply settings when the page loads
            window.addEventListener('load', loadConversation);

        })(); // End of IIFE
    </script>
</body>
</html>
