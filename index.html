<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Make it responsive and prevent zooming -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- PWA & Mobile App Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"> <!-- Or "default" or "black" -->
    <meta name="apple-mobile-web-app-title" content="Gemma Chat">
    <meta name="application-name" content="Gemma Chat">
    <meta name="theme-color" content="#0d6efd"> <!-- Match manifest theme_color -->

    <!-- Link to Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Icons (replace with your actual icon paths) -->
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192x192.png">
    <link rel="apple-touch-icon" href="icons/apple-touch-icon.png"> <!-- Typically 180x180 -->


    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <title>Gemma Chat</title>
    <style>
        /* --- General Reset & Base Styles --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            height: 100%;
            /* Prevent pull-to-refresh slightly */
            overscroll-behavior-y: contain;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; /* System fonts */
            height: 100%; /* Full viewport height */
            display: flex;
            flex-direction: column; /* Stack header, body, footer vertically */
            background: #e9ecef;
            color: #212529;
            transition: background 0.3s ease, color 0.3s ease;
            line-height: 1.4;
            overflow: hidden; /* Prevent body scrolling */
        }

        /* --- Theme: Dark Mode --- */
        body.dark {
            background: #212529;
            color: #f8f9fa;
        }
        .dark .chat-wrapper { background: #212529; /* Match body */ }
        .dark .chat-header { background: #343a40; border-bottom-color: #495057; }
        .dark .chat-footer { background: #343a40; border-top-color: #495057; }
        .dark .ai-msg { background: #495057; color: #f8f9fa; border-color: #6c757d; }
        .dark .ai-msg code, .dark .ai-msg pre { background: #6c757d; }
        .dark input[type="text"], .dark #api-key-input { background: #495057; color: #f8f9fa; border-color: #6c757d; }
        .dark button { /* Ensure buttons visible in dark mode */ }
        .dark .thinking { background: #495057; } /* Give thinking a bg */
        .dark .dot { background: #dee2e6; } /* Lighter dots */


        /* --- Layout: Chat Wrapper (Now the main layout container) --- */
        /* The .chat-wrapper is less important now, body handles the main layout */
        .chat-wrapper {
            display: flex;
            flex-direction: column;
            flex-grow: 1; /* Takes up all space in the body flex container */
            overflow: hidden; /* Redundant due to body, but safe */
            height: 100%; /* Ensure it fills the body */
        }

        /* --- Components: Header (Fixed/Sticky) --- */
        .chat-header {
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            flex-shrink: 0; /* Prevent shrinking */
            position: sticky; /* Keep at top */
            top: 0;
            background: #ffffff; /* Needs explicit background */
            z-index: 10; /* Above scrolling content */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Optional shadow */
        }
        .dark .chat-header { background: #343a40; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }


        .chat-header h1 {
            font-size: 1.1rem; /* Slightly smaller for app feel */
            font-weight: 600;
        }

        .controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        /* --- Components: Chat Body (Scrollable) --- */
        .chat-body {
            flex-grow: 1; /* Takes available space between header/footer */
            padding: 15px 15px 5px 15px; /* Add padding bottom to avoid footer overlap */
            overflow-y: auto; /* Enable vertical scrolling ONLY here */
            scroll-behavior: smooth;
            overscroll-behavior-y: contain; /* Prevent overscroll effects */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        /* --- Components: Messages --- */
        .message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 12px; /* Slightly more rounded */
            max-width: 80%;
            line-height: 1.45; /* Slightly more spacing */
            animation: fadeIn 0.3s ease;
            font-size: 0.95rem; /* Slightly larger for readability */
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05); /* Subtle shadow */
        }
        .dark .message { box-shadow: none; }

        .user-msg {
            background: #0d6efd;
            color: #fff;
            margin-left: auto;
            text-align: right;
            border-bottom-right-radius: 4px; /* Common chat bubble style */
        }
        .dark .user-msg { background: #0b5ed7; } /* Slightly adjusted dark blue */


        .ai-msg {
            background: #f1f3f5;
            color: #212529;
            /* Remove border for cleaner look */
            /* border: 1px solid #dee2e6; */
            margin-right: auto;
            text-align: left;
            border-bottom-left-radius: 4px; /* Common chat bubble style */
        }
        .dark .ai-msg {
            background: #495057;
            color: #f8f9fa;
        }

        /* Markdown Styles */
        .ai-msg p:last-child { margin-bottom: 0; }
        .ai-msg p { margin: 0 0 8px; }
        .ai-msg ul, .ai-msg ol { margin: 5px 0 8px 20px; padding-left: 15px; }
        .ai-msg li { margin: 4px 0; }
        .ai-msg strong { font-weight: 600; } /* Slightly less bold */
        .ai-msg em { font-style: italic; }
        .ai-msg code {
            background: #e0e0e0; /* Slightly darker code bg */
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; /* Monospace fonts */
            font-size: 0.88em;
        }
        .ai-msg pre {
             background: #e9ecef;
             padding: 10px; /* More padding */
             border-radius: 6px; /* More rounded */
             overflow-x: auto;
             margin: 10px 0;
             border: 1px solid #dee2e6; /* Add border to code blocks */
        }
         .dark .ai-msg pre { border-color: #555; }
         .ai-msg pre code { background: none; padding: 0; border-radius: 0; font-size: 1em; border: none;}

        /* Thinking Indicator */
        .thinking {
            display: flex;
            align-items: center;
            gap: 6px; /* More gap */
            padding: 10px 12px; /* Match message padding better */
            margin: 8px 0;
            max-width: fit-content;
            margin-right: auto;
            background: #f1f3f5; /* Match AI msg bg */
            border-radius: 12px;
            border-bottom-left-radius: 4px;
        }
        .dot {
            width: 7px; /* Slightly larger dots */
            height: 7px;
            background: #adb5bd; /* Grey dots */
            border-radius: 50%;
            animation: bounce 1.3s infinite ease-in-out;
        }
        .dot:nth-child(2) { animation-delay: 0.16s; }
        .dot:nth-child(3) { animation-delay: 0.32s; }

        /* --- Components: Footer (Fixed/Sticky) --- */
        .chat-footer {
            padding: 8px 10px; /* Reduced padding a bit */
            border-top: 1px solid #dee2e6;
            background: #ffffff; /* Explicit background */
            display: flex;
            flex-direction: column; /* Stack API key and input row */
            gap: 8px;
            flex-shrink: 0; /* Prevent shrinking */
            position: sticky; /* Keep at bottom */
            bottom: 0;
            z-index: 10; /* Above content */
            box-shadow: 0 -1px 3px rgba(0,0,0,0.05); /* Optional shadow */
        }
        .dark .chat-footer { background: #343a40; box-shadow: 0 -1px 3px rgba(0,0,0,0.2); }

        .config-row, /* Renamed from api-key-row */
        .input-row {
            display: flex;
            gap: 5px;
            width: 100%;
            align-items: center; /* Vertically align items in rows */
        }

        /* --- Components: Inputs & Buttons --- */
        input[type="text"],
        #api-key-input,
        #model-select { /* Apply styles to select too */
            flex-grow: 1;
            padding: 10px 12px;
            border: none;
            border-radius: 20px;
            font-size: 0.95rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease;
            min-width: 80px; /* Min width for select */
            height: 40px;
            background-color: #f1f3f5;
            color: #212529; /* Explicit color */
            -webkit-appearance: none; /* Remove default OS styling */
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236c757d%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); /* Basic dropdown arrow */
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 10px 10px;
            padding-right: 30px; /* Make space for arrow */
        }
        
        /* Ensure specific input doesn't grow excessively if select is present */
        #api-key-input {
            flex-grow: 2; /* Give API key more space if needed */
        }
        #model-select {
            flex-grow: 1;
            flex-basis: 150px; /* Suggest a base width */
            min-width: 120px;
        }
        
        .dark input[type="text"],
        .dark #api-key-input,
        .dark #model-select {
            background-color: #495057;
            color: #f8f9fa;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23adb5bd%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); /* Dark mode arrow */
        }

        /* Select focus style */
        #model-select:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.3);
        }

        /* Style for disabled select */
        #model-select:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }


        input:focus,
        #api-key-input:focus {
            outline: none;
            /* Use box-shadow for focus instead of border */
             box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.3);
        }

        button {
            padding: 0 15px; /* More horizontal padding */
            height: 40px; /* Match input height */
            background: #0d6efd;
            color: #fff;
            border: none;
            border-radius: 20px; /* Pill shape */
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: background 0.2s ease, transform 0.1s ease; /* Faster transform */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Prevent buttons shrinking too much */
        }

        button:hover {
            background: #0a58ca;
            /* Remove transform on hover for app feel */
            /* transform: translateY(-1px); */
        }
        button:active {
             transform: scale(0.97); /* Slight scale down on tap */
             background: #0a58ca;
        }

        #clear-btn { background: #6c757d; } /* Muted clear button */
        #clear-btn:hover { background: #5c636a; }
        #clear-btn:active { background: #5c636a; }


        #api-btn { 
            background: #198754; 
            flex-shrink: 0; /* Prevent shrinking */
                min-width: auto; /* Allow it to shrink if needed */
                padding: 0 12px; /* Adjust padding */
        } /* Give "Get Key" more width */
        #api-btn:hover { background: #157347; }
        #api-btn:active { background: #157347; }


        #file-btn {
            background: #6c757d;
            min-width: 40px; /* Keep it square-ish */
            padding: 0;
            font-size: 1.3rem; /* Larger icon */
            line-height: 1;
            border-radius: 50%; /* Circular button */
        }
        #file-btn:hover { background: #5c636a; }
        #file-btn:active { background: #5c636a; }


        #send-btn {
            min-width: 40px; /* Make send button potentially circular if text removed */
            padding: 0;
            border-radius: 50%; /* Circular */
             /* Add Send Icon (e.g., SVG or Font Awesome) inside the button in HTML if desired */
             /* Example: Replace "Send" text with an icon */
             font-size: 1.5rem; /* Adjust if using icon font */
        }

        #file-input { display: none; }

        /* --- Utilities: RTL Support --- */
        /* RTL styles should remain largely the same, check alignment */
        .rtl { direction: rtl; }
        .rtl .message { margin-left: 0; margin-right: auto; text-align: right; }
        .rtl .user-msg { margin-right: auto; margin-left: 0; text-align: left; border-bottom-right-radius: 12px; border-bottom-left-radius: 4px;}
        .rtl .ai-msg { margin-left: auto; margin-right: 0; text-align: right; border-bottom-left-radius: 12px; border-bottom-right-radius: 4px;}
        .rtl .thinking { margin-left: auto; margin-right: 0;}
        .rtl input[type="text"], .rtl #api-key-input { /* Text input already handles RTL */ }
        .rtl #model-select {
            background-position: left 10px center;
            padding-left: 30px;
            padding-right: 12px;
        }


        /* --- Animations --- */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Adjusted Bounce Animation */
        @keyframes bounce {
            0%, 70%, 100% { transform: scale(0.5); opacity: 0.5; }
            35% { transform: scale(1.0); opacity: 1; }
        }

    </style>
</head>
<body class="${localStorage.getItem('theme') === 'dark' ? 'dark' : ''}">

    <!-- Main Chat Application Wrapper -->
    <div class="chat-wrapper">

        <!-- Chat Header: Title and Controls (Sticky Top) -->
        <div class="chat-header">
            <h1 data-en="Gemma Chat" data-fa="چت نوا">Gemma Chat</h1>
            <div class="controls">
                <button id="theme-btn" data-en="Dark" data-fa="تاریک">
                    ${localStorage.getItem('theme') === 'dark' ? (localStorage.getItem('lang') === 'fa' ? 'روشن' : 'Light') : (localStorage.getItem('lang') === 'fa' ? 'تاریک' : 'Dark')}
                </button>
                <button id="lang-btn" data-en="Persian" data-fa="انگلیسی">
                    ${localStorage.getItem('lang') === 'fa' ? 'انگلیسی' : 'Persian'}
                </button>
                <button id="clear-btn" data-en="Clear Chat" data-fa="پاک کردن چت">Clear Chat</button>
            </div>
        </div>

        <!-- Chat Messages Area (Scrollable) -->
        <div class="chat-body" id="chat-body">
            <!-- Messages will be loaded here -->
        </div>

        <!-- Chat Input Footer (Sticky Bottom) -->
        <div class="chat-footer">
            <!-- API Key & Model Selection Row -->
            <div class="config-row">
                 <input type="text" id="api-key-input"
                       placeholder="OpenRouter API Key"
                       data-en-placeholder="OpenRouter API Key"
                       data-fa-placeholder="کلید API OpenRouter"
                       value="${localStorage.getItem('apiKey') || ''}">

                 <!-- Model Selection Dropdown -->
                 <select id="model-select" title="Select AI Model">
                    <option value="" data-en="Loading Models..." data-fa="در حال بارگیری مدل‌ها...">Loading Models...</option>
                    <!-- Models will be populated here by JS -->
                 </select>

                 <button id="api-btn" data-en="Key" data-fa="کلید">Key</button>
            </div>

            <!-- Input Row -->
            <div class="input-row">
                <button id="file-btn" title="Attach file">📎</button>
                <input type="text" id="chat-input"
                       placeholder="Type your message..."
                       data-en-placeholder="Type your message..."
                       data-fa-placeholder="پیام خود را تایپ کنید...">
                <button id="send-btn" title="Send message">➤</button>
                <input type="file" id="file-input" accept="image/*,application/pdf,text/plain">
            </div>
        </div>

    </div><!-- /.chat-wrapper -->

    <script>
         // IIFE to encapsulate chat logic and avoid global scope pollution
(function() {
    "use strict"; // Enable strict mode

    // --- State Variables ---
    let conversation = JSON.parse(localStorage.getItem('conversation')) || [];
    let apiKey = localStorage.getItem('apiKey') || '';
    let selectedModelId = localStorage.getItem('selectedModelId') || ''; // Load saved model ID
    let isTyping = false;
    let isDark = localStorage.getItem('theme') === 'dark';
    let isPersian = localStorage.getItem('lang') === 'fa';
    let availableModels = []; // To store fetched models

    // --- DOM Element References ---
    const chatBody = document.getElementById('chat-body');
    const apiKeyInput = document.getElementById('api-key-input');
    const modelSelect = document.getElementById('model-select'); // Get dropdown reference
    const chatInput = document.getElementById('chat-input');
    const fileInput = document.getElementById('file-input');
    const themeBtn = document.getElementById('theme-btn');
    const langBtn = document.getElementById('lang-btn');
    const clearBtn = document.getElementById('clear-btn');
    const apiBtn = document.getElementById('api-btn');
    const sendBtn = document.getElementById('send-btn');
    const fileBtn = document.getElementById('file-btn');
    const sendBtnElement = document.getElementById('send-btn');

    // --- Core Functions ---

    /**
     * Updates the UI based on the current theme and language settings.
     */
    function updateUI() {
        document.body.classList.toggle('dark', isDark);
        document.body.classList.toggle('rtl', isPersian);

        document.querySelectorAll('[data-en]').forEach(el => {
            if (el.id !== 'send-btn' && el.tagName !== 'OPTION') { // Exclude options updated elsewhere
                 el.textContent = isPersian ? el.getAttribute('data-fa') : el.getAttribute('data-en');
            }
        });

        document.querySelectorAll('[data-en-placeholder]').forEach(el => {
            el.placeholder = isPersian ? el.getAttribute('data-fa-placeholder') : el.getAttribute('data-en-placeholder');
        });

        themeBtn.textContent = isDark ? (isPersian ? 'روشن' : 'Light') : (isPersian ? 'تاریک' : 'Dark');
        langBtn.textContent = isPersian ? 'انگلیسی' : 'Persian';
        apiBtn.textContent = isPersian ? 'کلید' : 'Key';
        clearBtn.textContent = isPersian ? (window.innerWidth < 400 ? 'پاک' : 'پاک کردن چت') : (window.innerWidth < 400 ? 'Clear' : 'Clear Chat');
        sendBtnElement.title = isPersian ? 'ارسال پیام' : 'Send message';

        // Update loading/placeholder text in dropdown
        const loadingOption = modelSelect.querySelector('option[value=""]');
        if (loadingOption && !availableModels.length) { // Update only if still loading
            loadingOption.textContent = isPersian ? 'در حال بارگیری...' : 'Loading Models...';
            loadingOption.setAttribute('data-en', 'Loading Models...');
            loadingOption.setAttribute('data-fa', 'در حال بارگیری...');
        } else if (loadingOption && availableModels.length === 0) { // Handle no models found
             loadingOption.textContent = isPersian ? 'مدلی یافت نشد' : 'No Models Found';
             loadingOption.setAttribute('data-en', 'No Models Found');
             loadingOption.setAttribute('data-fa', 'مدلی یافت نشد');
        }


        const themeColorMeta = document.querySelector('meta[name="theme-color"]');
        if (themeColorMeta) {
            themeColorMeta.content = isDark ? '#343a40' : '#0d6efd';
        }
    }

    /**
     * Fetches models from OpenRouter API and populates the dropdown.
     */
    async function loadAndPopulateModels() {
        modelSelect.disabled = true; // Disable while loading
        const loadingOption = modelSelect.options[0]; // Keep reference to the placeholder
        loadingOption.textContent = isPersian ? 'در حال بارگیری...' : 'Loading Models...';

        try {
            const response = await fetch('https://openrouter.ai/api/v1/models');
            if (!response.ok) {
                throw new Error(`API Error (${response.status}): ${await response.text()}`);
            }
            const data = await response.json();

            availableModels = data.data
                .filter(model => model.id.endsWith(':free')) // Filter for free models
                .sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically by name

            // Clear existing options except the placeholder
            while (modelSelect.options.length > 1) {
                modelSelect.remove(1);
            }

            if (availableModels.length === 0) {
                 loadingOption.textContent = isPersian ? 'مدل رایگانی یافت نشد' : 'No Free Models Found';
                 loadingOption.setAttribute('data-en', 'No Free Models Found');
                 loadingOption.setAttribute('data-fa', 'مدل رایگانی یافت نشد');
                 console.warn("No free models found via OpenRouter API.");
                 return; // Exit if no free models
            }

            // Populate dropdown
            availableModels.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                // Display name, remove the "(free)" part for cleaner look if present
                option.textContent = model.name.replace(/\(free\)$/i, '').trim();
                modelSelect.appendChild(option);
            });

            // Try to set the previously selected model
            if (selectedModelId && modelSelect.querySelector(`option[value="${selectedModelId}"]`)) {
                modelSelect.value = selectedModelId;
            } else if (availableModels.length > 0) {
                // If no previous selection or previous is invalid, select the first available one
                selectedModelId = availableModels[0].id; // Update state variable
                modelSelect.value = selectedModelId;
                saveState(); // Save the default selection
            }

            // Remove the "Loading..." placeholder option now that we have models
             if (modelSelect.options[0].value === "") {
                 modelSelect.remove(0);
             }

            modelSelect.disabled = false; // Re-enable dropdown

        } catch (error) {
            console.error("Error fetching or processing models:", error);
            loadingOption.textContent = isPersian ? 'خطا در بارگیری' : 'Load Error';
            addMessage(isPersian ? `خطا در بارگیری مدل‌ها: ${error.message}` : `Error loading models: ${error.message}`, false);
            // Keep dropdown disabled on error
        }
    }


    /**
     * Scrolls the chat body to the bottom smoothly.
     */
    function scrollToBottom() {
        // Same as before
        setTimeout(() => {
             chatBody.scrollTo({
                top: chatBody.scrollHeight,
                behavior: 'smooth'
             });
        }, 50);
    }


    /**
     * Loads the initial state (conversation, settings) and triggers model loading.
     */
    function loadInitialState() {
        chatBody.innerHTML = ''; // Clear existing messages
        let needsScroll = conversation.length > 0;

        conversation.forEach(msg => {
             const isUser = msg.role === 'user';
             let displayContent = '[Message content unavailable]';
             if (Array.isArray(msg.content) && msg.content.length > 0) {
                 const firstPart = msg.content[0];
                 if (firstPart.type === 'text') { displayContent = firstPart.text; }
                 else if (firstPart.type === 'image_url') { displayContent = isPersian ? '[تصویر بارگذاری شد]' : '[Image loaded]'; }
             } else if (typeof msg.content === 'string') { displayContent = msg.content; }
             addMessage(displayContent, isUser, false);
        });

        apiKeyInput.value = apiKey;
        updateUI(); // Apply theme/lang first

        // Load models *after* initial UI setup
        loadAndPopulateModels(); // This will handle setting the dropdown value

        if (needsScroll) {
            setTimeout(() => {
                 chatBody.scrollTop = chatBody.scrollHeight;
            }, 100);
        }
    }

    /**
     * Adds a message bubble to the chat body.
     * @param {string} content - The message text or description.
     * @param {boolean} [isUser=false] - True if the message is from the user.
     * @param {boolean} [shouldScroll=true] - True to scroll the new message into view.
     */
     function addMessage(content, isUser = false, shouldScroll = true) {
        // Same as before
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${isUser ? 'user-msg' : 'ai-msg'}`;

        if (isUser) {
            msgDiv.textContent = content;
        } else {
            if (typeof marked !== 'undefined') {
                 marked.setOptions({ breaks: true, gfm: true });
                 msgDiv.innerHTML = marked.parse(content || '');
            } else {
                 console.error("Marked library not loaded.");
                 msgDiv.textContent = content;
            }
        }
        chatBody.appendChild(msgDiv);
        if (shouldScroll) { scrollToBottom(); }
    }

    /**
     * Adds a "thinking" animation.
     * @returns {HTMLElement} The thinking indicator element.
     */
    function addThinking() {
        // Same as before
         const existingThinking = chatBody.querySelector('.thinking');
         if(existingThinking) { removeThinking(existingThinking); }
        const thinkingDiv = document.createElement('div');
        thinkingDiv.className = 'thinking';
        thinkingDiv.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
        chatBody.appendChild(thinkingDiv);
        scrollToBottom();
        return thinkingDiv;
    }

    /**
     * Removes the thinking indicator element.
     * @param {HTMLElement} thinkingElement - The element to remove.
     */
    function removeThinking(thinkingElement) {
        // Same as before
        if (thinkingElement && thinkingElement.parentNode === chatBody) {
            chatBody.removeChild(thinkingElement);
        }
    }

    /**
     * Saves the current state to localStorage.
     */
    function saveState() {
        try {
            localStorage.setItem('conversation', JSON.stringify(conversation));
            localStorage.setItem('apiKey', apiKey);
            localStorage.setItem('selectedModelId', selectedModelId); // Save selected model
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            localStorage.setItem('lang', isPersian ? 'fa' : 'en');
        } catch (e) {
            console.error("Error saving state to localStorage:", e);
            addMessage(isPersian ? "خطا در ذخیره وضعیت چت." : "Error saving chat state.", false);
        }
    }

    /**
     * Converts a file to a Base64 encoded string.
     */
    function getBase64(file) {
        // Same as before
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });
    }

    /**
     * Sends the user's message (text and/or file) to the OpenRouter API.
     * @param {File} [file=null] - An optional file to upload.
     */
    async function sendMessage(file = null) {
        if (isTyping) return;

        apiKey = apiKeyInput.value.trim();
        // Get selected model ID *at the time of sending*
        const currentModelId = modelSelect.value;
        const messageText = chatInput.value.trim();

        // --- Input Validation ---
        if (!apiKey) {
            addMessage(isPersian ? 'لطفاً کلید API OpenRouter معتبر خود را وارد کنید.' : 'Please enter your valid OpenRouter API key.', false);
            apiKeyInput.focus();
            return;
        }
        if (!currentModelId) { // Check if a model is selected
             addMessage(isPersian ? 'لطفاً یک مدل هوش مصنوعی را انتخاب کنید.' : 'Please select an AI model.', false);
             modelSelect.focus();
             return;
        }
        if (!messageText && !file) {
            return;
        }

        isTyping = true;
        sendBtn.disabled = true;
        chatInput.disabled = true;
        fileBtn.disabled = true;
        apiKeyInput.disabled = true;
        modelSelect.disabled = true; // Disable model select during request


        let thinkingIndicator;
        let userDisplayMessageAdded = false;
        let currentMessageContent = [];

        // --- Prepare Message Payload (Text) ---
        if (messageText) {
            currentMessageContent.push({ type: 'text', text: messageText });
            addMessage(messageText, true);
            userDisplayMessageAdded = true;
            chatInput.value = '';
        }

        // --- Prepare Message Payload (File) ---
        if (file) {
            try {
                const base64Data = await getBase64(file);
                const fileType = file.type;
                let fileDescription = "";

                if (fileType.startsWith('image/')) {
                     currentMessageContent.push({ type: 'image_url', image_url: { url: base64Data } });
                     fileDescription = isPersian ? `[تصویر ارسال شد: ${file.name}]` : `[Image sent: ${file.name}]`;
                } else if (fileType === 'application/pdf' || fileType === 'text/plain') {
                    currentMessageContent.push({ type: 'text', text: `[User uploaded file: ${file.name}, type: ${fileType}]` });
                     fileDescription = isPersian ? `[فایل ارسال شد: ${file.name}]` : `[File sent: ${file.name}]`;
                } else {
                    addMessage(isPersian ? `نوع فایل پشتیبانی نمی‌شود: ${fileType}` : `Unsupported file type: ${fileType}`, false);
                    // Reset state
                    isTyping = false; sendBtn.disabled = false; chatInput.disabled = false; fileBtn.disabled = false; apiKeyInput.disabled = false; modelSelect.disabled = false;
                    return;
                }

                if (!userDisplayMessageAdded && fileDescription) {
                     addMessage(fileDescription, true);
                     userDisplayMessageAdded = true;
                }
                fileInput.value = '';

            } catch (error) {
                console.error("File processing error:", error);
                addMessage(isPersian ? `خطا در پردازش فایل: ${error.message}` : `File processing error: ${error.message}`, false);
                // Reset state
                isTyping = false; sendBtn.disabled = false; chatInput.disabled = false; fileBtn.disabled = false; apiKeyInput.disabled = false; modelSelect.disabled = false;
                return;
            }
        }

        thinkingIndicator = addThinking(); // Show thinking indicator

        const userMsg = { role: 'user', content: currentMessageContent };
        conversation.push(userMsg);
        // Don't save state until AI responds successfully

        // --- API Call ---
        try {
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json',
                    'HTTP-Referer': window.location.origin,
                    'X-Title': 'Gemma Chat PWA',
                },
                body: JSON.stringify({
                    model: currentModelId, // Use the currently selected model
                    messages: conversation,
                }),
            });

            removeThinking(thinkingIndicator);

            if (!response.ok) {
                let errorDetails = `API Error (${response.status})`;
                try {
                    const errorData = await response.json();
                    errorDetails += `: ${errorData.error?.message || response.statusText}`;
                } catch (jsonError) { errorDetails += `: ${await response.text()}`; }
                // Remove the last user message from history on API error? Maybe not. Let user retry.
                // conversation.pop(); // Optional: Remove user message if API fails
                throw new Error(errorDetails);
            }

            const data = await response.json();

            if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                const aiContent = data.choices[0].message.content;
                const aiMsg = { role: 'assistant', content: [{ type: 'text', text: aiContent }] };
                conversation.push(aiMsg); // Add AI response to history
                addMessage(aiContent, false);
                saveState(); // Save conversation *including* AI response
            } else {
                throw new Error("Invalid response structure received from API.");
            }

        } catch (error) {
            console.error("API Request Error:", error);
            if (thinkingIndicator) removeThinking(thinkingIndicator);
            addMessage(isPersian ? `خطا: ${error.message}` : `Error: ${error.message}`, false);
            // Maybe remove the last user message from conversation here if desired?
            // conversation.pop();
            // saveState(); // If removing the user message
        } finally {
            // --- Reset State ---
            isTyping = false;
            sendBtn.disabled = false;
            chatInput.disabled = false;
            fileBtn.disabled = false;
            apiKeyInput.disabled = false;
            modelSelect.disabled = false; // Re-enable model select
            chatInput.focus();
        }
    }

    // --- Event Listeners ---

    sendBtn.addEventListener('click', () => sendMessage());
    chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });
    fileBtn.addEventListener('click', () => { fileInput.click(); });
    fileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (file) { sendMessage(file); } });

    clearBtn.addEventListener('click', () => {
        if (confirm(isPersian ? "آیا مطمئن هستید که می‌خواهید کل تاریخچه چت را پاک کنید؟" : "Are you sure you want to clear the entire chat history?")) {
             conversation = []; chatBody.innerHTML = ''; localStorage.removeItem('conversation');
             // Keep API key and model selection
             saveState(); // Save other state changes potentially
        }
    });

    themeBtn.addEventListener('click', () => { isDark = !isDark; updateUI(); saveState(); });
    langBtn.addEventListener('click', () => { isPersian = !isPersian; updateUI(); saveState(); });
    apiBtn.addEventListener('click', () => { window.open('https://openrouter.ai/settings/keys', '_blank', 'noopener noreferrer'); });

    // Save API Key when input loses focus or Enter is pressed
    apiKeyInput.addEventListener('change', () => {
        apiKey = apiKeyInput.value.trim();
        saveState();
    });
     apiKeyInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            apiKey = apiKeyInput.value.trim();
            saveState();
            apiKeyInput.blur(); // Remove focus
        }
    });


    // Listener for Model Selection Change
    modelSelect.addEventListener('change', () => {
        selectedModelId = modelSelect.value;
        saveState(); // Save the new selection immediately
    });

    // --- Initialization ---
    window.addEventListener('load', loadInitialState); // Use the new load function

    // Optional: Update UI on resize
    let resizeTimeout;
    window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(updateUI, 150); });

})(); // End of IIFE
    </script>
</body>
</html>
